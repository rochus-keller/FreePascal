/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University
modified by Rochus Keller, me@rochus-keller.ch, (c) 2019

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

/*----------------------------------------------------------------------
Parser.h Specification
-----------------------------------------------------------------------*/

-->begin

// This file was automatically generated by Coco/R; don't modify it.
#if !defined(-->prefixCOCO_PARSER_H__)
#define -->prefixCOCO_PARSER_H__

-->headerdef

-->namespace_open

class PpLexer;
class Parser {
private:
-->constantsheader
	int errDist;
	int minErrDist;

	void SynErr(int n, const char* ctx = 0);
	void Get();
	void Expect(int n, const char* ctx = 0);
	bool StartOf(int s);
	void ExpectWeak(int n, int follow);
	bool WeakSeparator(int n, int syFol, int repFol);
    void SynErr(int line, int col, int n, const char* ctx, const QString&, const QString& path );

public:
	PpLexer *scanner;
	struct Error
	{
		QString msg;
		int row, col;
		QString path;
	};
	QList<Error> errors;
	
	void error(int row, int col, const QString& msg, const QString& path)
	{
		Error e;
		e.row = row;
		e.col = col;
		e.msg = msg;
		e.path = path;
		errors.append(e);
	}

	Token d_cur;
	Token d_next;
	QList<Token> d_comments;
	struct TokDummy
	{
		int kind;
	};
	TokDummy d_dummy;
	TokDummy *la;			// lookahead token
	
	int peek( quint8 la = 1 );

    void RunParser();

    
-->declarations

	Parser(PpLexer *scanner);
	~Parser();
	void SemErr(const char* msg);

-->productionsheader
	void Parse();

}; // end Parser

-->namespace_close

#endif

-->implementation

/*----------------------------------------------------------------------
Parser.cpp Specification
-----------------------------------------------------------------------*/

-->begin

// This file was automatically generated by Coco/R; don't modify it.
#include "LisaParser.h"
#include "LisaPpLexer.h"


-->namespace_open

static QString coco_string_create( const wchar_t* str )
{
    return QString::fromStdWString(str);
}

int Parser::peek( quint8 la )
{
	if( la == 0 )
		return d_cur.d_type;
	else if( la == 1 )
		return d_next.d_type;
	else
		return scanner->peekToken( la - 1 ).d_type;
}

void Parser::RunParser()
{
    d_stack.push(&d_root);
    Parse();
    d_stack.pop();
}
    
void Parser::SynErr(int n, const char* ctx) {
    if (errDist >= minErrDist)
       SynErr(d_next.d_lineNr, d_next.d_colNr, n, ctx, QString(), d_next.d_sourcePath);
	errDist = 0;
}

void Parser::SemErr(const char* msg) {
	if (errDist >= minErrDist)
		error(d_cur.d_lineNr, d_cur.d_colNr, msg, d_cur.d_sourcePath);
	errDist = 0;
}

void Parser::Get() {
	for (;;) {
		d_cur = d_next;
		d_next = scanner->nextToken();
        bool deliverToParser = false;
        switch( d_next.d_type )
        {
        case Lisa::Tok_Invalid:
        	if( !d_next.d_val.isEmpty() )
                error( d_next.d_lineNr, d_next.d_colNr, d_next.d_val, d_next.d_sourcePath );
            // else errors already handeled in lexer
            break;
        case Lisa::Tok_Comment:
            d_comments.append(d_next);
            break;
        default:
            deliverToParser = true;
            break;
        }

        if( deliverToParser )
        {
            if( d_next.d_type == Lisa::Tok_Eof )
                d_next.d_type = _EOF;

            la->kind = d_next.d_type;
            if (la->kind <= maxT)
            {
                ++errDist;
                break;
            }
        }
-->pragmas
		d_next = d_cur;
	}
}

void Parser::Expect(int n, const char* ctx ) {
	if (la->kind==n) Get(); else { SynErr(n, ctx); }
}

void Parser::ExpectWeak(int n, int follow) {
	if (la->kind == n) Get();
	else {
		SynErr(n);
		while (!StartOf(follow)) Get();
	}
}

bool Parser::WeakSeparator(int n, int syFol, int repFol) {
	if (la->kind == n) {Get(); return true;}
	else if (StartOf(repFol)) {return false;}
	else {
		SynErr(n);
		while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
			Get();
		}
		return StartOf(syFol);
	}
}

-->productions


// If the user declared a method Init and a mehtod Destroy they should
// be called in the contructur and the destructor respctively.
//
// The following templates are used to recognize if the user declared
// the methods Init and Destroy.

template<typename T>
struct ParserInitExistsRecognizer {
	template<typename U, void (U::*)() = &U::Init>
	struct ExistsIfInitIsDefinedMarker{};

	struct InitIsMissingType {
		char dummy1;
	};
	
	struct InitExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static InitIsMissingType is_here(...);

	// exist only if ExistsIfInitIsDefinedMarker is defined
	template<typename U>
	static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

	enum { InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType)) };
};

template<typename T>
struct ParserDestroyExistsRecognizer {
	template<typename U, void (U::*)() = &U::Destroy>
	struct ExistsIfDestroyIsDefinedMarker{};

	struct DestroyIsMissingType {
		char dummy1;
	};
	
	struct DestroyExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static DestroyIsMissingType is_here(...);

	// exist only if ExistsIfDestroyIsDefinedMarker is defined
	template<typename U>
	static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

	enum { DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType)) };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller {
	static void CallInit(T *t) {
		// nothing to do
	}
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true> {
	static void CallInit(T *t) {
		t->Init();
	}
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller {
	static void CallDestroy(T *t) {
		// nothing to do
	}
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true> {
	static void CallDestroy(T *t) {
		t->Destroy();
	}
};

void Parser::Parse() {
	d_cur = Token();
	d_next = Token();
	Get();
-->parseRoot
}

Parser::Parser(PpLexer *scanner) {
-->constants
	ParserInitCaller<Parser>::CallInit(this);
	la = &d_dummy;
	minErrDist = 2;
	errDist = minErrDist;
	this->scanner = scanner;
}

bool Parser::StartOf(int s) {
	const bool T = true;
	const bool x = false;

-->initialization

	return set[s][la->kind];
}

Parser::~Parser() {
	ParserDestroyCaller<Parser>::CallDestroy(this);
}

void Parser::SynErr(int line, int col, int n, const char* ctx, const QString& str, const QString& path ) {
	QString s;
	QString ctxStr;
	if( ctx )
		ctxStr = QString( " in %1" ).arg(ctx);
    if( n == 0 )
        s = QString("EOF expected%1").arg(ctxStr);
    else if( n < TT_Specials )
        s = QString("'%2' expected%1").arg(ctxStr).arg(tokenTypeString(n));
    else if( n <= TT_Max )
        s = QString("%2 expected%1").arg(ctxStr).arg(tokenTypeString(n));
    else
	switch (n) {
-->errors
		default:
		{
			s = QString( "generic error %1").arg(n);
		}
		break;
	}
    if( !str.isEmpty() )
        s = QString("%1 %2").arg(s).arg(str);
	error(line, col, s, path);
	//count++;
}

-->namespace_close
