// Author of this file: Rochus Keller <mailto:me@rochus-keller.ch> (July 2023)
// First attempt, copied grammar from https://github.com/graemeg/fpGUI/blob/master/docs/fpc_lang_ref.ipf
//   - Adapted to EbnfStudio syntax with minor corrections
//   - Adapted keywords from FP Language Reference 3.2.2 with additions to accommodate the given syntax
//   - Unfortunately not complete (e.g. missing generics ) and different productions than lang ref
// Therefore new attempt: transcribing all syntax diagrams from the lang ref to ebnf
//   - added digit suffix to productions with same name but different structure
//   - removed name variations (e.g. hint_directive vs hintdirective), added obviously missing productions
//     (e.g. variable_reference), and corrected obviously wrong productions (e.g. with_statement, exception_address)
//   - integrated unused in existing productions based on examples in fpc 3.2.2 source tree
//   - could defer some of the undefined productions from examples in the fpc source tree, but not all, see TODO
//   - consolidated productions to avoid alternative LL(1) conflicts
//   - refactorings and prefixes to get rid of successor ambiguities
//   - fixed/adapted syntax based on fpc 3.2.2 source tree while debugging the parser; a lot of stuff was missing
//     (e.g. reintroduce modifier, inherited statement und expression)
//   - get rid of pseudo keywords (section "1.3.3 Modifiers" in the spec) as far as possible; seems to generate even more problems
//  Intermediate conclusion: we cannot parse all of the FP 3.2.2 compiler sources with a generated parser ein either
//     way, with or without pseudo keywords; if we allow for pseudo keyword, e.g. line 238 in aasmbase.pas gives an error;
//     if we do without pseudo keywords, var modifiers are confused with next var declaration; this can only be avoided
//     by a (hand crafted) parser able to do decisions about how to use idents based on context.

#define _have_pseudo_keyords_

FreePascal ::= program_ | unit_ | library_

program_ ::= program_header ';' [ uses_clause ] block '.'
program_header ::= program identifier [ '(' program_parameters ')' ]
program_parameters ::= identifier_list
uses_clause ::= uses uses_clause_ { ',' uses_clause_ } ';'
uses_clause_ ::= identifier [ in string_literal ]

unit_ ::= unit_header interface_part implementation_part
		( [ initialization_part ] [ finalization_part ]
		| begin statement { ';' statement } ) end '.'
unit_header ::= unit identifier { '.' identifier } [hintdirectives] ';'
interface_part ::= interface [ uses_clause ] { constant_declaration_part | type_declaration_part
				| variable_declaration_part | property_declaration_part | procedure_headers_part }
procedure_headers_part ::= func_proc_header ';' [ call_modifiers ';' ]
implementation_part ::= implementation [ uses_clause ] { declaration_part }
initialization_part ::= initialization statement { ';' statement }
finalization_part ::= finalization statement { ';' statement }

library_ ::= library_header ';' [ uses_clause ] block '.'
library_header ::= library identifier

exports_clause ::= exports exports_list ';'
exports_list ::= exports_entry { ',' exports_entry }
exports_entry ::= identifier [ 'index' integer_constant ] [ 'name' string_constant ]

block ::= { declaration_part } statement_part

declaration_part ::= label_declaration_part | constant_declaration_part | resourcestring_declaration_part
					| type_declaration_part | variable_declaration_part 
					| threadvariable_declaration_part | func_proc_declaration_part
					| exports_clause // only in library_

label_declaration_part ::= label label_def { ',' label_def } ';'

constant_declaration_part ::= const constant_declaration { \LA: 1:ident & 2:('=' | ':') \ constant_declaration }

resourcestring_declaration_part ::= resourcestring string_constant_declaration 
								{ \LA: 1:ident & 2:'='\ string_constant_declaration }

type_declaration_part ::= type type_declaration {  \LA: 1:ident & 2:'='\ type_declaration }

variable_declaration_part ::= var variable_declaration { \LA: 1:ident & 2:(':'|',')\ variable_declaration }

threadvariable_declaration_part ::= threadvar variable_declaration 
								{ \LA: 1:ident & 2:':'\ variable_declaration }

func_proc_declaration_part ::= procedure_declaration | function_declaration
							| constructor_declaration | destructor_declaration

statement_part ::= compound_statement

hint_directive ::= 
#ifdef _have_pseudo_keyords_
                                'deprecated' [ string_constant ]
				| 'experimental' 
				| 'platform'
				| 'unimplemented'
#else
                                 ident [ string_constant ]
#endif

hintdirectives ::= hint_directive { \LL:2\ ';' hint_directive }

constant_declaration ::= identifier ( '=' expression | ':' type_ '=' typed_constant ) [hintdirectives] ';'
		// includes typed_constant_declaration

typed_constant_declaration- ::= identifier ':' type_ '=' typed_constant hintdirectives ';'

typed_constant ::= constant | address_constant | array_constant | record_constant | procedural_constant

type_declaration ::= identifier '=' type_ [hintdirectives] ';'

type_ ::= \LA: 2:'helper'\ helper_type
		| \LA: 1:'generic'\ generic_type 
		| \LL:1\ structured_type 
		| \LA: 1:'specialize'\ specialized_type
		| [type] simple_type // includes ident for type_alias 
		| pointer_type 
		| procedural_type 

simple_type ::= 
			\LA: 1:(string | 'ansistring' )\ string_type
			| ordinal_type // includes ident for real types
type_alias- ::= [type] identifier // migrated to type_
type_name ::= identifier
subrange_type ::= constant '..' constant
string_type ::= ( string | 'ansistring' ) [ '[' unsigned_integer ']' | '(' unsigned_integer ')' ] 
ordinal_type ::= \LA: 2:'..'\ subrange_type 
                    | enumerated_type 
                    | identifier // Integer, Shortint, SmallInt, Longint, ... , boolean, chars

identifier_list ::= identifier { ',' identifier }

enumerated_type ::= '(' enumerated_type_ { ',' enumerated_type_ } ')'
enumerated_type_ ::= assigned_enum_list // integrates identifier_list
assigned_enum_list ::= assigned_enum_ { \LL:2\ ',' assigned_enum_ }
assigned_enum_ ::= identifier [ ('=' | ':=') expression ]

structured_type ::=  \LA: 1:class & 2:of\ class_reference_type
				| packable_type_
				| interface_type | set_type | file_type

packable_type_ ::= [ packed | 'bitpacked' ] ( array_type | record_type | object_type | class_type )

array_type ::= array [ '[' ordinal_type { ',' ordinal_type } ']' ] of type_

old_record_type- ::= record [ field_list ] end
field_list ::= [ fixed_fields ] [';'] [ variant_part ] [';']
variant_part ::= case [ \LA: 2:':'\ identifier ':' ] ordinal_type of variant { \LL:2\ ';' variant }
variant ::= constant { ',' constant } ':' '(' field_list ')'
fixed_fields ::= fixed_field_ { \LL:2\ ';' fixed_field_ }
fixed_field_ ::= identifier_list ':' type_

record_type ::= record { component_list3 } end
component_list3 ::= [record_visibility_specifier] { \LA: 1:ident & 2:(':'|',')\ fixed_field_ } [';'] 
					{ record_method_definition }
					{ property_definition } { record_operator_definition } [ variant_part ] [';']
record_visibility_specifier ::= 'public' | [ 'strict' ] 'private'
record_method_definition ::= func_proc_header ';' [ call_modifiers ';' ]
record_operator_definition ::= class operator_definition

set_type ::= set of ordinal_type

file_type ::= file [ \LL:2\ of type_name ]

pointer_type ::= '^' type_name

procedural_type ::= func_proc_header [ \LL:2\ of object 
#ifdef _have_pseudo_keyords_
                                | \LL:2\ is 'nested' 
#else
                                | \LL:2\ is ident 
#endif
                                ] [ \LL:2\ ';' call_modifiers ]
func_proc_header ::= ( function | procedure ) identifier formal_parameter_list [ ':' result_type ]
call_modifiers ::= inline
#ifdef _have_pseudo_keyords_
                                | 'register' | 'cdecl' | 'pascal' | 'stdcall' | 'safecall'
#else
                                | ident
#endif

#ifndef _have_pseudo_keyords_
modifier_hintdirective2 ::= ( ident [ string_constant ] [ ident string_constant ]  | absolute expression)
#endif

variable_declaration ::= identifier_list ':' type_ [ '=' expression ] 
#ifdef _have_pseudo_keyords_
                                        [ \LA: 1:absolute | (1:';' & 2:('export'|'cvar'|'external'))\ variable_modifiers ] 
                                        [hintdirectives] ';'
variable_modifiers ::= variable_modifier_ 
                                        { \LA: 1:absolute | (1:';' & 2:('export'|'cvar'|'external'))\ variable_modifier_ }
variable_modifier_ ::= 
	absolute expression // integer expression or ident
	| ';' ( 'export' 
		| 'cvar'
		| 'external' [ string_constant ] [ 'name' string_constant ] ) 
#else
                // unfortunately this also fits the next variable_declaration; so we cannot cover this without pseudo keywords
                modifier_hintdirective2 { ';' modifier_hintdirective2 }
#endif

property_definition ::= identifier [ property_interface ] property_specifiers
property_interface ::= [ property_parameter_list ] ':' type_name [ 'index' integer_constant ]
property_parameter_list ::= '[' parameter_declaration { ';' parameter_declaration } ']'
property_specifiers ::= [ read_specifier ] [ write_specifier ] [ default_specifier ]
read_specifier ::= 'read' field_or_function
write_specifier ::= 'write' field_or_procedure
default_specifier ::= 'default' [ constant ] | 'nodefault'
field_or_function ::= identifier
field_or_procedure ::= identifier

object_type ::= object [ 'abstract' | 'sealed' ] [ heritage ] { component_list } end
heritage ::= '(' type_name ')' // object  type identifier
component_list ::= [ object_visibility_specifier ] { const_definition } { field_definition } { method_definition }
field_definition ::= [ [class] var ] identifier_list ':' type_ ';' [ 'static' ';' ]
const_definition ::= const identifier '=' constant_expression ';'
object_visibility_specifier ::= 'private' | 'protected' | 'public'

constructor_declaration ::= constructor_header ';' subroutine_block ';'
destructor_declaration ::= destructor_header ';' subroutine_block ';'
constructor_header ::= constructor  identifier [ '.' identifier ] formal_parameter_list
destructor_header ::= destructor identifier [ '.' identifier ] formal_parameter_list
					// original:  ( identifier | qualified_method_identifier )

method_definition ::= [class] ( func_proc_header | constructor_header | destructor_header ) ';'
					method_directives
method_directives ::= [ 'virtual' ';' [ 'abstract' ';' ] ] [ call_modifiers ';' ]

class_type ::= class [ [ 'abstract' | 'sealed' ] [ heritage2 ] { component_list2 } end ]
					// NOTE that Coco/R wrongly adds 'end' to the FIRST set of {component_list2}
heritage2 ::= '(' type_name  // class type identifier
				implemented_interfaces ')' 
implemented_interfaces ::= { ',' identifier } // interface identifier
component_list2 ::= [ class_visibility_specifier ] { field_definition2 } { class_part }
class_part ::= constant_declaration_part | type_declaration_part | 
			[class] ( variable_declaration_part | method_definition2 | property_definition2 )
				// includes class_variable_declaration_part
class_visibility_specifier ::= 'public' | 'published' | [ 'strict' ] ( 'private' | 'protected' )
method_definition2 ::= ( func_proc_header | constructor_header | destructor_header ) ';'
					[ method_directives2 ';' ] [ call_modifiers ';' ]
method_directives2 ::= ( 'virtual' | 'dynamic' ) [ \LL:2\ ';' ( 'abstract' | 'reintroduce' ) ]
					| 'override'
					| 'reintroduce'
					| 'message' ( integer_constant | string_constant )  
field_definition2 ::= identifier_list ':' type_ ';' [ 'static' ';' ]
class_variable_declaration_part- ::= class variable_declaration_part

property_definition2 ::= property identifier [ property_interface ] property_specifiers2 [hintdirectives]
property_specifiers2 ::= [ read_specifier ] [ write_specifier | implements_specifier ] [ default_specifier ]
					[ stored_specifier ] [ defaultarraypropertyspecifier ]
implements_specifier ::= 'implements' identifier { ',' identifier }
stored_specifier ::= 'stored' ( constant ) // | identifier covered by constant
defaultarraypropertyspecifier ::= ';' 'default'

interface_type ::= interface [ heritage ] [ guid ] { component_list2 } end // heritage only interface type identifiers
guid ::= '[' string_constant ']'

class_reference_type ::= class of type_name // classtype

generic_type ::= 'generic' identifier '<' template_list '>' '=' generic_type_ ';'
template_list ::= identifier_list2 { ';' identifier_list2 }
identifier_list2 ::= identifier_list [ ':' ( 
				type_name { ',' type_name }
				| class | interface | object | record ) ]
generic_type_ ::= class_type | object_type | interface_type | procedural_type | record_type | array_type

specialized_type ::= 'specialize' identifier '<' type_name_list '>'
type_name_list ::= type_name { ',' type_name }

helper_type ::= ( class | record | type ) 'helper' [ '(' base_helper ')' ] for identifier 
				helper_component_list { helper_component_list } end [hintdirectives]
helper_component_list ::= ( method_definition | property_definition )

// Objective C Class types (objcclass) not considered here

expression ::= simple_expression [ relop simple_expression ]
relop ::= '<' | '<=' | '>' | '>=' | '=' | '<>' | in | is
simple_expression ::= term { adop term }
adop ::= '+' | '-' | or | xor
term ::= factor { mulop factor }
mulop ::= '*' | '/' | div | mod | and | shl | shr | as
factor ::= '(' expression ')' | varref_or_funcall_or_constid_or_cast | unsigned_constant |
		not factor | sign factor | set_constructor | address_factor | inherited_call
varref_or_funcall_or_constid_or_cast ::= selector  [ actual_parameter_list ]
				// includes constant_identifier and qualified_method_designator
unsigned_constant ::= unsigned_number | character_string | nil
sign ::= '+' | '-'

function_call- ::= ( function_identifier | method_designator | qualified_method_designator | variable_reference )
				[ actual_parameter_list ]
actual_parameter_list ::= '(' [ expression { ',' expression } ] ')'

set_constructor ::= '[' [ set_group { ',' set_group } ] ']'
set_group ::= expression [ '..' expression ]

value_typecast- ::= type_name '(' expression ')'

address_factor ::= '@' identifier [ '.' identifier ]
		// for ( variable_reference | function_identifier | procedure_identifier |  qualified_method_identifier )

constant_expression ::= expression

statement ::= [ \LL:2\ label_def ':' ] [ simple_statement | structured_statement | asm_statement ]

simple_statement ::= inherited_call | assig_or_call | goto_statement | raise_statement

assig_or_call ::= variable_reference ( assigop expression | [ actual_parameter_list ] )
			// replaces assignment_statement and procedure_statement

inherited_call ::= 'inherited' [ identifier [ actual_parameter_list ] ]

assignment_statement- ::= ( variable_reference | function_identifier ) assigop expression
assigop ::= ':=' | '+=' | '-=' | '*=' | '/='

procedure_statement- ::= ( procedure_identifier | method_designator | qualified_method_identifier
						| variable_reference ) [ actual_parameter_list ]

goto_statement ::= goto label_def

structured_statement ::= compound_statement | conditional_statement | repetitive_statement
						| with_statement | try_statement

conditional_statement ::= case_statement | if_statement

repetitive_statement ::= for_statement | repeat_statement | while_statement

compound_statement ::= begin statement { ';' statement } end

statement_list ::= statement { \LL:2\ ';' statement }

case_statement ::= case expression of case_part { \LL:2\ ';' case_part } [ else_part ] [ ';' ] end
case_part ::= case_range { ',' case_range } ':' statement
case_range ::= constant [ '..' constant ]
else_part ::= ( else | 'otherwise' ) statement_list

if_statement ::= if expression then statement [ else statement ]

for_statement ::= for control_variable  ( 
					':=' initial_value ( to | downto ) final_value 
					| in enumerable ) do statement
				// includes for_in_statement
control_variable ::= variable_identifier
initial_value ::= expression
final_value ::= expression

for_in_statement- ::= for control_variable in enumerable do statement
enumerable ::= enumerated_type 
			| identifier | set_constructor  // instead of expression, TODO: array value

repeat_statement ::= repeat statement_list until expression

while_statement ::= while expression do statement

with_statement ::= with variable_reference { ',' variable_reference }

asm_statement ::= asm // assembler_code to be delivered by lexer with asm keyword
				end [ register_list ]
register_list ::= '[' string_constant { ',' string_constant } ']'

procedure_declaration ::= procedure_header ';' subroutine_block ';'
procedure_header ::= procedure  identifier ['.' identifier] formal_parameter_list
					// original:  ( identifier | qualified_method_identifier )
					modifiers_hintdirectives
subroutine_block ::= block | external_directive | asm_block | 'forward'

function_declaration ::= function_header ';' subroutine_block ';'
function_header ::= function identifier ['.' identifier] formal_parameter_list ':' result_type
					// original:  ( identifier | qualified_method_identifier )
					modifiers_hintdirectives

#ifndef _have_pseudo_keyords_
modifier_hintdirective ::= ( inline | ident [ \LL:2\ ( ident | ':' ) string_constant ] )
#endif

modifiers_hintdirectives ::= 
#ifdef _have_pseudo_keyords_
                                        [ \LL:2\ modifiers ] [hintdirectives]
#else
                                        { \LL:2\ ';' modifier_hintdirective }
#endif


formal_parameter_list ::= [ '(' parameter_declaration { ';' parameter_declaration } ')' ]
parameter_declaration ::= value_parameter | variable_parameter | out_parameter |  constant_parameter
value_parameter ::= identifier_list ':' [ array of ] parameter_type [ '=' default_parameter_value ]
				// includes: identifier ':' type_name '=' default_parameter_value
variable_parameter ::= var identifier_list [ ':' [ array of ] type_name ]
out_parameter ::= out identifier_list [ ':' [ array of ] type_name ]
constant_parameter ::= const identifier_list [ ':' [ array of ] type_name ]
					// covered by value_parameter:  identifier ':' type_name '=' default_parameter_value

external_directive ::= 'external' [ string_constant [ 'name' string_constant | 'index' integer_constant] ]

asm_block ::= 'assembler' ';' { declaration_part } // TODO  asm_statement

#ifdef _have_pseudo_keyords_
modifiers ::= ';' modifier { \LL:2\ ';' modifier }
modifier ::= 
	'public' [ 'name' string_constant ]
	| 'export'
	| 'alias' ':' string_constant
	| 'interrupt'
	| 'noreturn'
	| 'iocheck'
	| call_modifiers2
call_modifiers2 ::= inline
                                 | 'cdecl' | 'cppdecl' | 'hardfloat' | 'local' | 'mwpascal' | 'ms_abi_default' | 'ms_abi_cdecl'
				| 'nostackframe' | 'overload' | 'pascal' | 'register'| 'safecall' | 'saveregisters' | 'softfloat'
				| 'stdcall' | 'sysv_abi_default' | 'sysv_abi_cdecl' | 'vectorcall' | 'varargs'
#endif

operator_definition ::= operator ( assignment_operator_definition | arithmetic_operator_definition
							| comparison_operator_definition | logical_operator_definition
							| other_operator_definition ) [ result_identifier ] ':' result_type
							';' subroutine_block
assignment_operator_definition ::= ( ':=' | 'explicit' ) '(' value_parameter ')'
arithmetic_operator_definition ::= ( '+' | '-' | '*' | '/' | '**' | '><' ) '(' parameter_list ')'
comparison_operator_definition ::= ( '=' | '<' | '<=' | '>' | '>=' | '<>' | in ) '(' parameter_list ')'
logical_operator_definition ::= ( and | or | xor | not ) '(' parameter_list ')'
other_operator_definition ::= ( ident // ident instead of 'enumerator' | 'inc' | 'dec' 
                                                        ) '(' parameter_list ')'

raise_statement ::= raise [ exception_instance [ exception_address ] ]
exception_address ::= 'at' address_expression { ',' address_expression }

try_statement ::= try statement_list ( except exceptionhandlers | finally statement_list ) end
				// includes try_finally_statement
exceptionhandlers ::= [ statement_list | exception_handler { ';' exception_handler } else statement_list ]
exception_handler ::= on [ \LA: 2:':'\ identifier ':' ] type_name //  class_type_identifier
					do statement 

// Guessed from lang spec textual description (no syntax diagram available):
string_literal ::= string_constant
string_constant ::= character_string
integer_constant ::= unsigned_integer
result_type ::= type_ // The result type of a function can be any previously declared type
property_declaration_part ::= property property_definition ';' { property_definition ';' } // TODO: confirm
exception_instance ::= identifier
result_identifier ::= identifier
qualified_method_identifier- ::= identifier '.' identifier
variable_reference ::= selector
function_identifier- ::= identifier
procedure_identifier- ::= identifier
variable_identifier ::= identifier
parameter_list ::= parameter_declaration { ';' parameter_declaration }
method_designator- ::= identifier
default_parameter_value ::= expression
parameter_type ::= type_name 
//////

// Guessed from existing fpc 3.2.2 source tree:
constant ::= unsigned_number | string_constant | identifier
base_helper ::= identifier
string_constant_declaration ::= identifier '=' string_constant ';'
address_expression ::= expression // results in CodePointer or Pointer
/////

// TODO: 
address_constant ::= 
array_constant ::= '(' expression { ',' expression } ')'
record_constant ::= 
procedural_constant ::= 
//////

label_def ::= decimal_int | identifier

// not used: signed_number ::= [ '+' | '-' ] unsigned_number
unsigned_number ::= unsigned_integer | unsigned_real
unsigned_integer ::= decimal_int | hex_int | octal_int | binary_int

character_string ::= ( quoted_string | control_string ) { quoted_string | control_string }
control_string ::= '#' unsigned_integer

selector ::= identifier { '.' identifier | '[' expression {',' expression} ']' | '^' }

// with this trick we can use the non-keywords as idents where possible
identifier ::= ident
#ifdef pseudo_idents
	| 'index' | 'name' | 'deprecated' | 'experimental' | 'platform'
	| 'bitpacked' | 'public' | 'strict' | 'private' | 'nested'
	| 'export' | 'cvar' | 'read' | 'write' | 'unimplemented' | 'ansistring' 
	| 'nodefault' | 'static' | 'protected' | 'virtual' | 'abstract' 
	| 'sealed' | 'published' | 'dynamic' | 'override' | 'message' | 'implements' | 'stored' 
	| 'default' | 'generic' | 'specialize' | 'helper' | 'otherwise' | 'forward' | 'external' 
	| 'assembler' | 'alias' | 'interrupt' | 'noreturn' | 'iocheck' | 'cdecl' | 'cppdecl' | 'hardfloat' 
	| 'local' | 'mwpascal' | 'ms_abi_default' | 'ms_abi_cdecl' | 'nostackframe' | 'overload' 
	| 'pascal' | 'register'| 'safecall' | 'saveregisters' | 'softfloat' | 'stdcall' | 'sysv_abi_default' 
	| 'sysv_abi_cdecl' | 'vectorcall' | 'varargs' | 'explicit' | 'enumerator' | 'inc' | 'dec' | 'at' 
#endif

// lexer tokens
ident ::=
unsigned_real ::=
decimal_int ::= // digit sequence
hex_int ::=  // $ hex digit sequence
octal_int ::= // & octal digit sequence
binary_int ::= // % bin digit sequence
quoted_string ::=

// Helper Tokens
Comment ::=
Directive ::=
comment- ::= '(*' '*)' '{' '}'

// Pragmas
%module ::= 'FreePascal'
%namespace ::= 'Fp'
%suppress ::= ';' ',' '.' '#'
