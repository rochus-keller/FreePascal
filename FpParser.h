#ifndef __FP_PARSER__
#define __FP_PARSER__
// This file was automatically generated by EbnfStudio; don't modify it!

#include <FreePascal/FpSynTree.h>

namespace Fp {

	class Scanner {
	public:
		virtual Token next() = 0;
		virtual Token peek(int offset) = 0;
	};

	class Parser {
	public:
		Parser(Scanner* s):scanner(s) {}
		void RunParser();
		SynTree root;
		struct Error {
		    QString msg;
		    int row, col;
		    QString path;
		    Error( const QString& m, int r, int c, const QString& p):msg(m),row(r),col(c),path(p){}
		};
		QList<Error> errors;
	protected:
		void FreePascal(SynTree*);
		void program_(SynTree*);
		void program_header(SynTree*);
		void program_parameters(SynTree*);
		void uses_clause(SynTree*);
		void uses_clause_(SynTree*);
		void unit_(SynTree*);
		void unit_header(SynTree*);
		void interface_part(SynTree*);
		void procedure_headers_part(SynTree*);
		void implementation_part(SynTree*);
		void initialization_part(SynTree*);
		void finalization_part(SynTree*);
		void library_(SynTree*);
		void library_header(SynTree*);
		void exports_clause(SynTree*);
		void exports_list(SynTree*);
		void exports_entry(SynTree*);
		void block(SynTree*);
		void declaration_part(SynTree*);
		void label_declaration_part(SynTree*);
		void constant_declaration_part(SynTree*);
		void resourcestring_declaration_part(SynTree*);
		void type_declaration_part(SynTree*);
		void variable_declaration_part(SynTree*);
		void threadvariable_declaration_part(SynTree*);
		void func_proc_declaration_part(SynTree*);
		void statement_part(SynTree*);
		void hint_directive(SynTree*);
		void hintdirectives(SynTree*);
		void constant_declaration(SynTree*);
		void typed_constant(SynTree*);
		void type_declaration(SynTree*);
		void type_(SynTree*);
		void simple_type(SynTree*);
		void type_name(SynTree*);
		void subrange_type(SynTree*);
		void string_type(SynTree*);
		void ordinal_type(SynTree*);
		void identifier_list(SynTree*);
		void enumerated_type(SynTree*);
		void enumerated_type_(SynTree*);
		void assigned_enum_list(SynTree*);
		void assigned_enum_(SynTree*);
		void structured_type(SynTree*);
		void packable_type_(SynTree*);
		void array_type(SynTree*);
		void field_list(SynTree*);
		void variant_part(SynTree*);
		void variant(SynTree*);
		void fixed_fields(SynTree*);
		void fixed_field_(SynTree*);
		void record_type(SynTree*);
		void component_list3(SynTree*);
		void record_visibility_specifier(SynTree*);
		void record_method_definition(SynTree*);
		void record_operator_definition(SynTree*);
		void set_type(SynTree*);
		void file_type(SynTree*);
		void pointer_type(SynTree*);
		void procedural_type(SynTree*);
		void func_proc_header(SynTree*);
		void call_modifiers(SynTree*);
		void variable_declaration(SynTree*);
		void variable_modifiers(SynTree*);
		void variable_modifier_(SynTree*);
		void property_definition(SynTree*);
		void property_interface(SynTree*);
		void property_parameter_list(SynTree*);
		void property_specifiers(SynTree*);
		void read_specifier(SynTree*);
		void write_specifier(SynTree*);
		void default_specifier(SynTree*);
		void field_or_function(SynTree*);
		void field_or_procedure(SynTree*);
		void object_type(SynTree*);
		void heritage(SynTree*);
		void component_list(SynTree*);
		void field_definition(SynTree*);
		void const_definition(SynTree*);
		void object_visibility_specifier(SynTree*);
		void constructor_declaration(SynTree*);
		void destructor_declaration(SynTree*);
		void constructor_header(SynTree*);
		void destructor_header(SynTree*);
		void method_definition(SynTree*);
		void method_directives(SynTree*);
		void class_type(SynTree*);
		void heritage2(SynTree*);
		void implemented_interfaces(SynTree*);
		void component_list2(SynTree*);
		void class_part(SynTree*);
		void class_visibility_specifier(SynTree*);
		void method_definition2(SynTree*);
		void method_directives2(SynTree*);
		void field_definition2(SynTree*);
		void property_definition2(SynTree*);
		void property_specifiers2(SynTree*);
		void implements_specifier(SynTree*);
		void stored_specifier(SynTree*);
		void defaultarraypropertyspecifier(SynTree*);
		void interface_type(SynTree*);
		void guid(SynTree*);
		void class_reference_type(SynTree*);
		void generic_type(SynTree*);
		void template_list(SynTree*);
		void identifier_list2(SynTree*);
		void generic_type_(SynTree*);
		void specialized_type(SynTree*);
		void type_name_list(SynTree*);
		void helper_type(SynTree*);
		void helper_component_list(SynTree*);
		void expression(SynTree*);
		void relop(SynTree*);
		void simple_expression(SynTree*);
		void adop(SynTree*);
		void term(SynTree*);
		void mulop(SynTree*);
		void factor(SynTree*);
		void varref_or_funcall_or_constid_or_cast(SynTree*);
		void unsigned_constant(SynTree*);
		void sign(SynTree*);
		void actual_parameter_list(SynTree*);
		void set_constructor(SynTree*);
		void set_group(SynTree*);
		void address_factor(SynTree*);
		void constant_expression(SynTree*);
		void statement(SynTree*);
		void simple_statement(SynTree*);
		void assig_or_call(SynTree*);
		void inherited_call(SynTree*);
		void assigop(SynTree*);
		void goto_statement(SynTree*);
		void structured_statement(SynTree*);
		void conditional_statement(SynTree*);
		void repetitive_statement(SynTree*);
		void compound_statement(SynTree*);
		void statement_list(SynTree*);
		void case_statement(SynTree*);
		void case_part(SynTree*);
		void case_range(SynTree*);
		void else_part(SynTree*);
		void if_statement(SynTree*);
		void for_statement(SynTree*);
		void control_variable(SynTree*);
		void initial_value(SynTree*);
		void final_value(SynTree*);
		void enumerable(SynTree*);
		void repeat_statement(SynTree*);
		void while_statement(SynTree*);
		void with_statement(SynTree*);
		void asm_statement(SynTree*);
		void register_list(SynTree*);
		void procedure_declaration(SynTree*);
		void procedure_header(SynTree*);
		void subroutine_block(SynTree*);
		void function_declaration(SynTree*);
		void function_header(SynTree*);
		void modifiers_hintdirectives(SynTree*);
		void formal_parameter_list(SynTree*);
		void parameter_declaration(SynTree*);
		void value_parameter(SynTree*);
		void variable_parameter(SynTree*);
		void out_parameter(SynTree*);
		void constant_parameter(SynTree*);
		void external_directive(SynTree*);
		void asm_block(SynTree*);
		void modifiers(SynTree*);
		void modifier(SynTree*);
		void call_modifiers2(SynTree*);
		void operator_definition(SynTree*);
		void assignment_operator_definition(SynTree*);
		void arithmetic_operator_definition(SynTree*);
		void comparison_operator_definition(SynTree*);
		void logical_operator_definition(SynTree*);
		void other_operator_definition(SynTree*);
		void raise_statement(SynTree*);
		void exception_address(SynTree*);
		void try_statement(SynTree*);
		void exceptionhandlers(SynTree*);
		void exception_handler(SynTree*);
		void string_literal(SynTree*);
		void string_constant(SynTree*);
		void integer_constant(SynTree*);
		void result_type(SynTree*);
		void property_declaration_part(SynTree*);
		void exception_instance(SynTree*);
		void result_identifier(SynTree*);
		void variable_reference(SynTree*);
		void variable_identifier(SynTree*);
		void parameter_list(SynTree*);
		void default_parameter_value(SynTree*);
		void parameter_type(SynTree*);
		void constant(SynTree*);
		void base_helper(SynTree*);
		void string_constant_declaration(SynTree*);
		void address_expression(SynTree*);
		void array_constant(SynTree*);
		void label_def(SynTree*);
		void unsigned_number(SynTree*);
		void unsigned_integer(SynTree*);
		void character_string(SynTree*);
		void control_string(SynTree*);
		void selector(SynTree*);
		void identifier(SynTree*);
	protected:
		Token cur;
		Token la;
		Scanner* scanner;
		void next();
		int peek(int off);
		void invalid(const char* what);
		void expect(int tt, const char* where);
	};
}
#endif // include
