

// This file was automatically generated by Coco/R; don't modify it.
#if !defined(Fp_COCO_PARSER_H__)
#define Fp_COCO_PARSER_H__

#include <QStack>
#include <FreePascal/FpSynTree.h>


namespace Fp {


class PpLexer;
class Parser {
private:
	enum {
		_EOF=0,
		_T_Literals_=1,
		_T_Hash=2,
		_T_Lpar=3,
		_T_Latt=4,
		_T_Rpar=5,
		_T_Star=6,
		_T_Ratt=7,
		_T_2Star=8,
		_T_StarEq=9,
		_T_Plus=10,
		_T_PlusEq=11,
		_T_Comma=12,
		_T_Minus=13,
		_T_MinusEq=14,
		_T_Dot=15,
		_T_2Dot=16,
		_T_Slash=17,
		_T_SlashEq=18,
		_T_Colon=19,
		_T_ColonEq=20,
		_T_Semi=21,
		_T_Lt=22,
		_T_Leq=23,
		_T_LtGt=24,
		_T_Eq=25,
		_T_Gt=26,
		_T_GtLt=27,
		_T_Geq=28,
		_T_At=29,
		_T_Lbrack=30,
		_T_Rbrack=31,
		_T_Hat=32,
		_T_Lbrace=33,
		_T_Rbrace=34,
		_T_Keywords_=35,
		_T_absolute=36,
		_T_abstract=37,
		_T_alias=38,
		_T_and=39,
		_T_ansistring=40,
		_T_array=41,
		_T_as=42,
		_T_asm=43,
		_T_assembler=44,
		_T_at=45,
		_T_begin=46,
		_T_bitpacked=47,
		_T_case=48,
		_T_cdecl=49,
		_T_class=50,
		_T_const=51,
		_T_constructor=52,
		_T_cppdecl=53,
		_T_cvar=54,
		_T_dec=55,
		_T_default=56,
		_T_deprecated=57,
		_T_destructor=58,
		_T_div=59,
		_T_do=60,
		_T_downto=61,
		_T_dynamic=62,
		_T_else=63,
		_T_end=64,
		_T_enumerator=65,
		_T_except=66,
		_T_experimental=67,
		_T_explicit=68,
		_T_export=69,
		_T_exports=70,
		_T_external=71,
		_T_file=72,
		_T_finalization=73,
		_T_finally=74,
		_T_for=75,
		_T_forward=76,
		_T_function=77,
		_T_generic=78,
		_T_goto=79,
		_T_hardfloat=80,
		_T_helper=81,
		_T_if=82,
		_T_implementation=83,
		_T_implements=84,
		_T_in=85,
		_T_inc=86,
		_T_index=87,
		_T_initialization=88,
		_T_inline=89,
		_T_interface=90,
		_T_interrupt=91,
		_T_iocheck=92,
		_T_is=93,
		_T_label=94,
		_T_library=95,
		_T_local=96,
		_T_message=97,
		_T_mod=98,
		_T_ms_abi_cdecl=99,
		_T_ms_abi_default=100,
		_T_mwpascal=101,
		_T_name=102,
		_T_nested=103,
		_T_nil=104,
		_T_nodefault=105,
		_T_noreturn=106,
		_T_nostackframe=107,
		_T_not=108,
		_T_object=109,
		_T_of=110,
		_T_on=111,
		_T_operator=112,
		_T_or=113,
		_T_otherwise=114,
		_T_out=115,
		_T_overload=116,
		_T_override=117,
		_T_packed=118,
		_T_pascal=119,
		_T_platform=120,
		_T_private=121,
		_T_procedure=122,
		_T_program=123,
		_T_property=124,
		_T_protected=125,
		_T_public=126,
		_T_published=127,
		_T_raise=128,
		_T_read=129,
		_T_record=130,
		_T_register=131,
		_T_repeat=132,
		_T_resourcestring=133,
		_T_safecall=134,
		_T_saveregisters=135,
		_T_sealed=136,
		_T_set=137,
		_T_shl=138,
		_T_shr=139,
		_T_softfloat=140,
		_T_specialize=141,
		_T_static=142,
		_T_stdcall=143,
		_T_stored=144,
		_T_strict=145,
		_T_string=146,
		_T_sysv_abi_cdecl=147,
		_T_sysv_abi_default=148,
		_T_then=149,
		_T_threadvar=150,
		_T_to=151,
		_T_try=152,
		_T_type=153,
		_T_unimplemented=154,
		_T_unit=155,
		_T_until=156,
		_T_uses=157,
		_T_var=158,
		_T_varargs=159,
		_T_vectorcall=160,
		_T_virtual=161,
		_T_while=162,
		_T_with=163,
		_T_write=164,
		_T_xor=165,
		_T_Specials_=166,
		_T_address_constant=167,
		_T_array_constant=168,
		_T_record_constant=169,
		_T_procedural_constant=170,
		_T_ident=171,
		_T_unsigned_real=172,
		_T_decimal_int=173,
		_T_hex_int=174,
		_T_octal_int=175,
		_T_binary_int=176,
		_T_quoted_string=177,
		_T_Comment=178,
		_T_Directive=179,
		_T_Eof=180,
		_T_MaxToken_=181
	};
	int maxT;

	int errDist;
	int minErrDist;

	void SynErr(int n, const char* ctx = 0);
	void Get();
	void Expect(int n, const char* ctx = 0);
	bool StartOf(int s);
	void ExpectWeak(int n, int follow);
	bool WeakSeparator(int n, int syFol, int repFol);
    void SynErr(int line, int col, int n, const char* ctx, const QString&, const QString& path );

public:
	PpLexer *scanner;
	struct Error
	{
		QString msg;
		int row, col;
		QString path;
	};
	QList<Error> errors;
	
	void error(int row, int col, const QString& msg, const QString& path)
	{
		Error e;
		e.row = row;
		e.col = col;
		e.msg = msg;
		e.path = path;
		errors.append(e);
	}

	Token d_cur;
	Token d_next;
	QList<Token> d_comments;
	struct TokDummy
	{
		int kind;
	};
	TokDummy d_dummy;
	TokDummy *la;			// lookahead token
	
	int peek( quint8 la = 1 );

    void RunParser();

    
Fp::SynTree d_root;
	QStack<Fp::SynTree*> d_stack;
	void addTerminal() {
		if( d_cur.d_type != Fp::Tok_Semi && d_cur.d_type != Fp::Tok_Comma && d_cur.d_type != Fp::Tok_Dot && d_cur.d_type != Fp::Tok_Hash ){
			Fp::SynTree* n = new Fp::SynTree( d_cur ); d_stack.top()->d_children.append(n);
		}
	}



	Parser(PpLexer *scanner);
	~Parser();
	void SemErr(const char* msg);

	void FreePascal();
	void program_();
	void unit_();
	void library_();
	void program_header();
	void uses_clause();
	void block();
	void identifier();
	void program_parameters();
	void identifier_list();
	void uses_clause_();
	void string_literal();
	void unit_header();
	void interface_part();
	void implementation_part();
	void initialization_part();
	void finalization_part();
	void statement();
	void hintdirectives();
	void constant_declaration_part();
	void type_declaration_part();
	void variable_declaration_part();
	void property_declaration_part();
	void procedure_headers_part();
	void func_proc_header();
	void call_modifiers();
	void declaration_part();
	void library_header();
	void exports_clause();
	void exports_list();
	void exports_entry();
	void integer_constant();
	void string_constant();
	void statement_part();
	void label_declaration_part();
	void resourcestring_declaration_part();
	void threadvariable_declaration_part();
	void func_proc_declaration_part();
	void label_def();
	void constant_declaration();
	void string_constant_declaration();
	void type_declaration();
	void variable_declaration();
	void procedure_declaration();
	void function_declaration();
	void constructor_declaration();
	void destructor_declaration();
	void compound_statement();
	void hint_directive();
	void expression();
	void type_();
	void typed_constant();
	void constant();
	void helper_type();
	void generic_type();
	void structured_type();
	void specialized_type();
	void simple_type();
	void pointer_type();
	void procedural_type();
	void string_type();
	void ordinal_type();
	void type_name();
	void subrange_type();
	void unsigned_integer();
	void enumerated_type();
	void enumerated_type_();
	void assigned_enum_list();
	void assigned_enum_();
	void class_reference_type();
	void packable_type_();
	void interface_type();
	void set_type();
	void file_type();
	void array_type();
	void record_type();
	void object_type();
	void class_type();
	void field_list();
	void fixed_fields();
	void variant_part();
	void variant();
	void fixed_field_();
	void component_list3();
	void record_visibility_specifier();
	void record_method_definition();
	void property_definition();
	void record_operator_definition();
	void operator_definition();
	void formal_parameter_list();
	void result_type();
	void variable_modifiers();
	void variable_modifier_();
	void property_interface();
	void property_specifiers();
	void property_parameter_list();
	void parameter_declaration();
	void read_specifier();
	void write_specifier();
	void default_specifier();
	void field_or_function();
	void field_or_procedure();
	void heritage();
	void component_list();
	void object_visibility_specifier();
	void const_definition();
	void field_definition();
	void method_definition();
	void constant_expression();
	void constructor_header();
	void subroutine_block();
	void destructor_header();
	void method_directives();
	void heritage2();
	void component_list2();
	void implemented_interfaces();
	void class_visibility_specifier();
	void field_definition2();
	void class_part();
	void method_definition2();
	void property_definition2();
	void method_directives2();
	void property_specifiers2();
	void implements_specifier();
	void stored_specifier();
	void defaultarraypropertyspecifier();
	void guid();
	void template_list();
	void generic_type_();
	void identifier_list2();
	void type_name_list();
	void base_helper();
	void helper_component_list();
	void simple_expression();
	void relop();
	void term();
	void adop();
	void factor();
	void mulop();
	void varref_or_funcall_or_constid_or_cast();
	void unsigned_constant();
	void sign();
	void set_constructor();
	void address_factor();
	void actual_parameter_list();
	void unsigned_number();
	void character_string();
	void set_group();
	void simple_statement();
	void structured_statement();
	void asm_statement();
	void assig_or_call();
	void goto_statement();
	void raise_statement();
	void assigop();
	void conditional_statement();
	void repetitive_statement();
	void with_statement();
	void try_statement();
	void case_statement();
	void if_statement();
	void for_statement();
	void repeat_statement();
	void while_statement();
	void statement_list();
	void case_part();
	void else_part();
	void case_range();
	void control_variable();
	void initial_value();
	void final_value();
	void enumerable();
	void variable_identifier();
	void variable_reference();
	void register_list();
	void procedure_header();
	void modifiers();
	void external_directive();
	void asm_block();
	void function_header();
	void value_parameter();
	void variable_parameter();
	void out_parameter();
	void constant_parameter();
	void parameter_type();
	void default_parameter_value();
	void modifier();
	void call_modifiers2();
	void assignment_operator_definition();
	void arithmetic_operator_definition();
	void comparison_operator_definition();
	void logical_operator_definition();
	void other_operator_definition();
	void result_identifier();
	void parameter_list();
	void exception_instance();
	void exception_address();
	void address_expression();
	void exceptionhandlers();
	void exception_handler();
	void control_string();

	void Parse();

}; // end Parser

} // namespace


#endif

