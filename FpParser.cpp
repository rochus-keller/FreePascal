

// This file was automatically generated by Coco/R; don't modify it.
#include "FpParser.h"
#include "FpPpLexer.h"


namespace Fp {


static QString coco_string_create( const wchar_t* str )
{
    return QString::fromStdWString(str);
}

int Parser::peek( quint8 la )
{
	if( la == 0 )
		return d_cur.d_type;
	else if( la == 1 )
		return d_next.d_type;
	else
		return scanner->peekToken( la - 1 ).d_type;
}

void Parser::RunParser()
{
    d_stack.push(&d_root);
    Parse();
    d_stack.pop();
}
    
void Parser::SynErr(int n, const char* ctx) {
    if (errDist >= minErrDist)
       SynErr(d_next.d_lineNr, d_next.d_colNr, n, ctx, QString(), d_next.d_sourcePath);
	errDist = 0;
}

void Parser::SemErr(const char* msg) {
	if (errDist >= minErrDist)
		error(d_cur.d_lineNr, d_cur.d_colNr, msg, d_cur.d_sourcePath);
	errDist = 0;
}

void Parser::Get() {
	for (;;) {
		d_cur = d_next;
		d_next = scanner->nextToken();
        bool deliverToParser = false;
        switch( d_next.d_type )
        {
        case Fp::Tok_Invalid:
        	if( !d_next.d_val.isEmpty() )
                error( d_next.d_lineNr, d_next.d_colNr, d_next.d_val, d_next.d_sourcePath );
            // else errors already handeled in lexer
            break;
        case Fp::Tok_Comment:
            d_comments.append(d_next);
            break;
        default:
            deliverToParser = true;
            break;
        }

        if( deliverToParser )
        {
            if( d_next.d_type == Fp::Tok_Eof )
                d_next.d_type = _EOF;

            la->kind = d_next.d_type;
            if (la->kind <= maxT)
            {
                ++errDist;
                break;
            }
        }

		d_next = d_cur;
	}
}

void Parser::Expect(int n, const char* ctx ) {
	if (la->kind==n) Get(); else { SynErr(n, ctx); }
}

void Parser::ExpectWeak(int n, int follow) {
	if (la->kind == n) Get();
	else {
		SynErr(n);
		while (!StartOf(follow)) Get();
	}
}

bool Parser::WeakSeparator(int n, int syFol, int repFol) {
	if (la->kind == n) {Get(); return true;}
	else if (StartOf(repFol)) {return false;}
	else {
		SynErr(n);
		while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
			Get();
		}
		return StartOf(syFol);
	}
}

void Parser::FreePascal() {
		d_stack.push(&d_root); 
		if (la->kind == _T_program) {
			program_();
		} else if (la->kind == _T_unit) {
			unit_();
		} else if (la->kind == _T_library) {
			library_();
		} else SynErr(183,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::program_() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_program_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		program_header();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_uses) {
			uses_clause();
		}
		block();
		Expect(_T_Dot,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::unit_() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_unit_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		unit_header();
		interface_part();
		implementation_part();
		if (la->kind == _T_end || la->kind == _T_finalization || la->kind == _T_initialization) {
			if (la->kind == _T_initialization) {
				initialization_part();
			}
			if (la->kind == _T_finalization) {
				finalization_part();
			}
		} else if (la->kind == _T_begin) {
			Get();
			addTerminal(); 
			statement();
			while (la->kind == _T_Semi) {
				Get();
				addTerminal(); 
				statement();
			}
		} else SynErr(184,__FUNCTION__);
		Expect(_T_end,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Dot,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::library_() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_library_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		library_header();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_uses) {
			uses_clause();
		}
		block();
		Expect(_T_Dot,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::program_header() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_program_header, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_program,__FUNCTION__);
		addTerminal(); 
		identifier();
		if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			program_parameters();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::uses_clause() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_uses_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_uses,__FUNCTION__);
		addTerminal(); 
		uses_clause_();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			uses_clause_();
		}
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::block() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		declaration_part();
		statement_part();
		d_stack.pop(); 
}

void Parser::identifier() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_index: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_name: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_deprecated: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_experimental: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_platform: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_bitpacked: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_public: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_strict: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_private: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_nested: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_export: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_cvar: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_read: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_write: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_unimplemented: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_ansistring: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_nodefault: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_static: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_protected: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_virtual: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_abstract: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_sealed: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_published: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_dynamic: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_override: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_message: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_implements: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_stored: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_default: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_generic: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_specialize: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_helper: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_otherwise: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_forward: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_external: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_assembler: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_alias: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_interrupt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_noreturn: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_iocheck: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_cdecl: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_cppdecl: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_hardfloat: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_inline: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_local: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_mwpascal: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_ms_abi_default: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_ms_abi_cdecl: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_nostackframe: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_overload: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_pascal: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_register: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_safecall: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_saveregisters: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_softfloat: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_stdcall: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_sysv_abi_default: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_sysv_abi_cdecl: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_vectorcall: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_varargs: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_explicit: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_enumerator: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_inc: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_dec: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_at: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_ident: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(185,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::program_parameters() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_program_parameters, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier_list();
		d_stack.pop(); 
}

void Parser::identifier_list() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_identifier_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			identifier();
		}
		d_stack.pop(); 
}

void Parser::uses_clause_() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_uses_clause_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		if (la->kind == _T_in) {
			Get();
			addTerminal(); 
			string_literal();
		}
		d_stack.pop(); 
}

void Parser::string_literal() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_string_literal, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		string_constant();
		d_stack.pop(); 
}

void Parser::unit_header() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_unit_header, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_unit,__FUNCTION__);
		addTerminal(); 
		identifier();
		while (la->kind == _T_Dot) {
			Get();
			addTerminal(); 
			identifier();
		}
		hintdirectives();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::interface_part() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_interface_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_interface,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_uses) {
			uses_clause();
		}
		while (StartOf(1)) {
			if (la->kind == _T_const) {
				constant_declaration_part();
			} else if (la->kind == _T_type) {
				type_declaration_part();
			} else if (la->kind == _T_var) {
				variable_declaration_part();
			} else if (la->kind == _T_property) {
				property_declaration_part();
			} else {
				procedure_headers_part();
			}
		}
		d_stack.pop(); 
}

void Parser::implementation_part() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_implementation_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_implementation,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_uses) {
			uses_clause();
		}
		declaration_part();
		d_stack.pop(); 
}

void Parser::initialization_part() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_initialization_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_initialization,__FUNCTION__);
		addTerminal(); 
		statement();
		while (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
			statement();
		}
		d_stack.pop(); 
}

void Parser::finalization_part() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_finalization_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_finalization,__FUNCTION__);
		addTerminal(); 
		statement();
		while (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
			statement();
		}
		d_stack.pop(); 
}

void Parser::statement() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (( peek(1) == _T_abstract || peek(1) == _T_alias || peek(1) == _T_ansistring || peek(1) == _T_assembler || peek(1) == _T_at || peek(1) == _T_bitpacked || peek(1) == _T_cdecl || peek(1) == _T_cppdecl || peek(1) == _T_cvar || peek(1) == _T_dec || peek(1) == _T_decimal_int || peek(1) == _T_default || peek(1) == _T_deprecated || peek(1) == _T_dynamic || peek(1) == _T_enumerator || peek(1) == _T_experimental || peek(1) == _T_explicit || peek(1) == _T_export || peek(1) == _T_external || peek(1) == _T_forward || peek(1) == _T_generic || peek(1) == _T_hardfloat || peek(1) == _T_helper || peek(1) == _T_ident || peek(1) == _T_implements || peek(1) == _T_inc || peek(1) == _T_index || peek(1) == _T_inline || peek(1) == _T_interrupt || peek(1) == _T_iocheck || peek(1) == _T_local || peek(1) == _T_message || peek(1) == _T_ms_abi_cdecl || peek(1) == _T_ms_abi_default || peek(1) == _T_mwpascal || peek(1) == _T_name || peek(1) == _T_nested || peek(1) == _T_nodefault || peek(1) == _T_noreturn || peek(1) == _T_nostackframe || peek(1) == _T_otherwise || peek(1) == _T_overload || peek(1) == _T_override || peek(1) == _T_pascal || peek(1) == _T_platform || peek(1) == _T_private || peek(1) == _T_protected || peek(1) == _T_public || peek(1) == _T_published || peek(1) == _T_read || peek(1) == _T_register || peek(1) == _T_safecall || peek(1) == _T_saveregisters || peek(1) == _T_sealed || peek(1) == _T_softfloat || peek(1) == _T_specialize || peek(1) == _T_static || peek(1) == _T_stdcall || peek(1) == _T_stored || peek(1) == _T_strict || peek(1) == _T_sysv_abi_cdecl || peek(1) == _T_sysv_abi_default || peek(1) == _T_unimplemented || peek(1) == _T_varargs || peek(1) == _T_vectorcall || peek(1) == _T_virtual || peek(1) == _T_write ) && peek(2) == _T_Colon ) {
			label_def();
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
		}
		if (StartOf(2)) {
			simple_statement();
		} else if (StartOf(3)) {
			structured_statement();
		} else if (la->kind == _T_asm) {
			asm_statement();
		} else SynErr(186,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::hintdirectives() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_hintdirectives, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(4)) {
			hint_directive();
			while (la->kind == _T_Semi) {
				Get();
				addTerminal(); 
				hint_directive();
			}
		}
		d_stack.pop(); 
}

void Parser::constant_declaration_part() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_constant_declaration_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_const,__FUNCTION__);
		addTerminal(); 
		while (StartOf(5)) {
			constant_declaration();
		}
		d_stack.pop(); 
}

void Parser::type_declaration_part() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_type_declaration_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_type,__FUNCTION__);
		addTerminal(); 
		type_declaration();
		while (StartOf(5)) {
			type_declaration();
		}
		d_stack.pop(); 
}

void Parser::variable_declaration_part() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_variable_declaration_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_var,__FUNCTION__);
		addTerminal(); 
		variable_declaration();
		while (StartOf(5)) {
			variable_declaration();
		}
		d_stack.pop(); 
}

void Parser::property_declaration_part() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_property_declaration_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_property,__FUNCTION__);
		addTerminal(); 
		property_definition();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		while (StartOf(5)) {
			property_definition();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::procedure_headers_part() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_procedure_headers_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		func_proc_header();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		if (StartOf(6)) {
			call_modifiers();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::func_proc_header() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_func_proc_header, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_function) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_procedure) {
			Get();
			addTerminal(); 
		} else SynErr(187,__FUNCTION__);
		formal_parameter_list();
		if (la->kind == _T_Colon) {
			Get();
			addTerminal(); 
			result_type();
		}
		d_stack.pop(); 
}

void Parser::call_modifiers() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_call_modifiers, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_register: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_cdecl: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_pascal: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_stdcall: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_safecall: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_inline: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(188,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::declaration_part() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_declaration_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		while (StartOf(7)) {
			if (la->kind == _T_label) {
				label_declaration_part();
			} else if (la->kind == _T_const) {
				constant_declaration_part();
			} else if (la->kind == _T_resourcestring) {
				resourcestring_declaration_part();
			} else if (la->kind == _T_type) {
				type_declaration_part();
			} else if (la->kind == _T_var) {
				variable_declaration_part();
			} else if (la->kind == _T_threadvar) {
				threadvariable_declaration_part();
			} else if (StartOf(8)) {
				func_proc_declaration_part();
			} else {
				exports_clause();
			}
		}
		d_stack.pop(); 
}

void Parser::library_header() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_library_header, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_library,__FUNCTION__);
		addTerminal(); 
		identifier();
		d_stack.pop(); 
}

void Parser::exports_clause() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_exports_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_exports,__FUNCTION__);
		addTerminal(); 
		exports_list();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::exports_list() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_exports_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		exports_entry();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			exports_entry();
		}
		d_stack.pop(); 
}

void Parser::exports_entry() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_exports_entry, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		if (la->kind == _T_index) {
			Get();
			addTerminal(); 
			integer_constant();
		}
		if (la->kind == _T_name) {
			Get();
			addTerminal(); 
			string_constant();
		}
		d_stack.pop(); 
}

void Parser::integer_constant() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_integer_constant, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		unsigned_integer();
		d_stack.pop(); 
}

void Parser::string_constant() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_string_constant, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		character_string();
		d_stack.pop(); 
}

void Parser::statement_part() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_statement_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		compound_statement();
		d_stack.pop(); 
}

void Parser::label_declaration_part() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_label_declaration_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_label,__FUNCTION__);
		addTerminal(); 
		label_def();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			label_def();
		}
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::resourcestring_declaration_part() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_resourcestring_declaration_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_resourcestring,__FUNCTION__);
		addTerminal(); 
		string_constant_declaration();
		while (StartOf(5)) {
			string_constant_declaration();
		}
		d_stack.pop(); 
}

void Parser::threadvariable_declaration_part() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_threadvariable_declaration_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_threadvar,__FUNCTION__);
		addTerminal(); 
		variable_declaration();
		while (StartOf(5)) {
			variable_declaration();
		}
		d_stack.pop(); 
}

void Parser::func_proc_declaration_part() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_func_proc_declaration_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		while (StartOf(9)) {
			if (la->kind == _T_procedure) {
				procedure_declaration();
			} else if (la->kind == _T_function) {
				function_declaration();
			} else if (la->kind == _T_constructor) {
				constructor_declaration();
			} else {
				destructor_declaration();
			}
		}
		d_stack.pop(); 
}

void Parser::label_def() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_label_def, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_decimal_int) {
			Get();
			addTerminal(); 
		} else if (StartOf(5)) {
			identifier();
		} else SynErr(189,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::constant_declaration() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_constant_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		if (la->kind == _T_Eq) {
			Get();
			addTerminal(); 
			expression();
		} else if (la->kind == _T_Colon) {
			Get();
			addTerminal(); 
			type_();
			Expect(_T_Eq,__FUNCTION__);
			addTerminal(); 
			typed_constant();
		} else SynErr(190,__FUNCTION__);
		hintdirectives();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::string_constant_declaration() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_string_constant_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		Expect(_T_Eq,__FUNCTION__);
		addTerminal(); 
		string_constant();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::type_declaration() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_type_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		Expect(_T_Eq,__FUNCTION__);
		addTerminal(); 
		type_();
		hintdirectives();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::variable_declaration() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_variable_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		type_();
		if (la->kind == _T_Eq) {
			Get();
			addTerminal(); 
			expression();
		}
		if (StartOf(10)) {
			variable_modifiers();
		}
		hintdirectives();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::procedure_declaration() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_procedure_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		procedure_header();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		subroutine_block();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::function_declaration() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_function_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		function_header();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		subroutine_block();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::constructor_declaration() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_constructor_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		constructor_header();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		subroutine_block();
		d_stack.pop(); 
}

void Parser::destructor_declaration() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_destructor_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		destructor_header();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		subroutine_block();
		d_stack.pop(); 
}

void Parser::compound_statement() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_compound_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_begin,__FUNCTION__);
		addTerminal(); 
		statement();
		while (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
			statement();
		}
		Expect(_T_end,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::hint_directive() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_hint_directive, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_deprecated) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Hash || la->kind == _T_quoted_string) {
				string_constant();
			}
		} else if (la->kind == _T_experimental) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_platform) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_unimplemented) {
			Get();
			addTerminal(); 
		} else SynErr(191,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::expression() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		simple_expression();
		if (StartOf(11)) {
			relop();
			simple_expression();
		}
		d_stack.pop(); 
}

void Parser::type_() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_type_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (peek(2) == _T_helper ) {
			helper_type();
		} else if (peek(1) == _T_generic ) {
			generic_type();
		} else if (( peek(1) == _T_bitpacked || peek(1) == _T_array || peek(1) == _T_class || peek(1) == _T_file || peek(1) == _T_interface || peek(1) == _T_object || peek(1) == _T_packed || peek(1) == _T_record || peek(1) == _T_set ) ) {
			structured_type();
		} else if (peek(1) == _T_specialize ) {
			specialized_type();
		} else if (StartOf(12)) {
			if (la->kind == _T_type) {
				Get();
				addTerminal(); 
			}
			simple_type();
		} else if (la->kind == _T_Hat) {
			pointer_type();
		} else if (la->kind == _T_function || la->kind == _T_procedure) {
			procedural_type();
		} else SynErr(192,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::typed_constant() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_typed_constant, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(13)) {
			constant();
		} else if (la->kind == _T_address_constant) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_array_constant) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_record_constant) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_procedural_constant) {
			Get();
			addTerminal(); 
		} else SynErr(193,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::constant() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_constant, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(14)) {
			unsigned_number();
		} else if (la->kind == _T_Hash || la->kind == _T_quoted_string) {
			string_constant();
		} else SynErr(194,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::helper_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_helper_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_class) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_record) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_type) {
			Get();
			addTerminal(); 
		} else SynErr(195,__FUNCTION__);
		Expect(_T_helper,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			base_helper();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		}
		Expect(_T_for,__FUNCTION__);
		addTerminal(); 
		identifier();
		helper_component_list();
		while (StartOf(15)) {
			helper_component_list();
		}
		Expect(_T_end,__FUNCTION__);
		addTerminal(); 
		hintdirectives();
		d_stack.pop(); 
}

void Parser::generic_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_generic_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_generic,__FUNCTION__);
		addTerminal(); 
		identifier();
		Expect(_T_Lt,__FUNCTION__);
		addTerminal(); 
		template_list();
		Expect(_T_Gt,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Eq,__FUNCTION__);
		addTerminal(); 
		generic_type_();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::structured_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_structured_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (peek(1) == _T_class && peek(2) == _T_of ) {
			class_reference_type();
		} else if (StartOf(16)) {
			packable_type_();
		} else if (la->kind == _T_interface) {
			interface_type();
		} else if (la->kind == _T_set) {
			set_type();
		} else if (la->kind == _T_file) {
			file_type();
		} else SynErr(196,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::specialized_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_specialized_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_specialize,__FUNCTION__);
		addTerminal(); 
		identifier();
		Expect(_T_Lt,__FUNCTION__);
		addTerminal(); 
		type_name_list();
		Expect(_T_Gt,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::simple_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_simple_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (peek(1) == _T_ansistring ) {
			string_type();
		} else if (StartOf(17)) {
			ordinal_type();
		} else SynErr(197,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::pointer_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_pointer_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Hat,__FUNCTION__);
		addTerminal(); 
		type_name();
		d_stack.pop(); 
}

void Parser::procedural_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_procedural_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		func_proc_header();
		if (la->kind == _T_is || la->kind == _T_of) {
			if (la->kind == _T_of) {
				Get();
				addTerminal(); 
				Expect(_T_object,__FUNCTION__);
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
				Expect(_T_nested,__FUNCTION__);
				addTerminal(); 
			}
		}
		if (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
			call_modifiers();
		}
		d_stack.pop(); 
}

void Parser::string_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_string_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_string) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_ansistring) {
			Get();
			addTerminal(); 
		} else SynErr(198,__FUNCTION__);
		if (la->kind == _T_Lpar || la->kind == _T_Lbrack) {
			if (la->kind == _T_Lbrack) {
				Get();
				addTerminal(); 
				unsigned_integer();
				Expect(_T_Rbrack,__FUNCTION__);
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
				unsigned_integer();
				Expect(_T_Rpar,__FUNCTION__);
				addTerminal(); 
			}
		}
		d_stack.pop(); 
}

void Parser::ordinal_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_ordinal_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(13)) {
			subrange_type();
		} else if (la->kind == _T_Lpar) {
			enumerated_type();
		} else if (StartOf(5)) {
			identifier();
		} else SynErr(199,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::type_name() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_type_name, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		d_stack.pop(); 
}

void Parser::subrange_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_subrange_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		constant();
		Expect(_T_2Dot,__FUNCTION__);
		addTerminal(); 
		constant();
		d_stack.pop(); 
}

void Parser::unsigned_integer() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_unsigned_integer, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_decimal_int) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_hex_int) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_octal_int) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_binary_int) {
			Get();
			addTerminal(); 
		} else SynErr(200,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::enumerated_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_enumerated_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		enumerated_type_();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			enumerated_type_();
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::enumerated_type_() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_enumerated_type_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		assigned_enum_list();
		d_stack.pop(); 
}

void Parser::assigned_enum_list() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_assigned_enum_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		assigned_enum_();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			assigned_enum_();
		}
		d_stack.pop(); 
}

void Parser::assigned_enum_() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_assigned_enum_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		if (la->kind == _T_ColonEq || la->kind == _T_Eq) {
			if (la->kind == _T_Eq) {
				Get();
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
			}
			expression();
		}
		d_stack.pop(); 
}

void Parser::class_reference_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_class_reference_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_class,__FUNCTION__);
		addTerminal(); 
		Expect(_T_of,__FUNCTION__);
		addTerminal(); 
		type_name();
		d_stack.pop(); 
}

void Parser::packable_type_() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_packable_type_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_bitpacked || la->kind == _T_packed) {
			if (la->kind == _T_packed) {
				Get();
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
			}
		}
		if (la->kind == _T_array) {
			array_type();
		} else if (la->kind == _T_record) {
			record_type();
		} else if (la->kind == _T_object) {
			object_type();
		} else if (la->kind == _T_class) {
			class_type();
		} else SynErr(201,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::interface_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_interface_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_interface,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Lpar) {
			heritage();
		}
		if (la->kind == _T_Lbrack) {
			guid();
		}
		while (StartOf(18)) {
			component_list2();
		}
		Expect(_T_end,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::set_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_set_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_set,__FUNCTION__);
		addTerminal(); 
		Expect(_T_of,__FUNCTION__);
		addTerminal(); 
		ordinal_type();
		d_stack.pop(); 
}

void Parser::file_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_file_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_file,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_of) {
			Get();
			addTerminal(); 
			type_name();
		}
		d_stack.pop(); 
}

void Parser::array_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_array_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_array,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Lbrack) {
			Get();
			addTerminal(); 
			ordinal_type();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				ordinal_type();
			}
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
		}
		Expect(_T_of,__FUNCTION__);
		addTerminal(); 
		type_();
		d_stack.pop(); 
}

void Parser::record_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_record_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_record,__FUNCTION__);
		addTerminal(); 
		while (StartOf(19)) {
			component_list3();
		}
		Expect(_T_end,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::object_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_object_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_object,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_abstract || la->kind == _T_sealed) {
			if (la->kind == _T_abstract) {
				Get();
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
			}
		}
		if (la->kind == _T_Lpar) {
			heritage();
		}
		while (StartOf(20)) {
			component_list();
		}
		Expect(_T_end,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::class_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_class_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_class,__FUNCTION__);
		addTerminal(); 
		if (StartOf(21)) {
			if (la->kind == _T_abstract || la->kind == _T_sealed) {
				if (la->kind == _T_abstract) {
					Get();
					addTerminal(); 
				} else {
					Get();
					addTerminal(); 
				}
			}
			if (la->kind == _T_Lpar) {
				heritage2();
			}
			while (StartOf(18)) {
				component_list2();
			}
			Expect(_T_end,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::field_list() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_field_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(5)) {
			fixed_fields();
			if (la->kind == _T_Semi) {
				Get();
				addTerminal(); 
			}
		}
		if (la->kind == _T_case) {
			variant_part();
		}
		if (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::fixed_fields() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_fixed_fields, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		fixed_field_();
		while (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
			fixed_field_();
		}
		d_stack.pop(); 
}

void Parser::variant_part() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_variant_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_case,__FUNCTION__);
		addTerminal(); 
		if (peek(2) == _T_Colon ) {
			identifier();
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
		}
		ordinal_type();
		Expect(_T_of,__FUNCTION__);
		addTerminal(); 
		variant();
		while (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
			variant();
		}
		d_stack.pop(); 
}

void Parser::variant() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_variant, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		constant();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			constant();
		}
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (StartOf(22)) {
			field_list();
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::fixed_field_() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_fixed_field_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier_list();
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		type_();
		d_stack.pop(); 
}

void Parser::component_list3() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_component_list3, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_private || la->kind == _T_public || la->kind == _T_strict) {
			record_visibility_specifier();
		}
		while (StartOf(5)) {
			fixed_field_();
		}
		if (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
		}
		while (la->kind == _T_function || la->kind == _T_procedure) {
			record_method_definition();
		}
		while (StartOf(5)) {
			property_definition();
		}
		while (la->kind == _T_class) {
			record_operator_definition();
		}
		if (la->kind == _T_case) {
			variant_part();
		}
		if (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::record_visibility_specifier() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_record_visibility_specifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_public) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_private || la->kind == _T_strict) {
			if (la->kind == _T_strict) {
				Get();
				addTerminal(); 
			}
			Expect(_T_private,__FUNCTION__);
			addTerminal(); 
		} else SynErr(202,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::record_method_definition() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_record_method_definition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		func_proc_header();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		if (StartOf(6)) {
			call_modifiers();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::property_definition() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_property_definition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		if (la->kind == _T_Colon || la->kind == _T_Lbrack) {
			property_interface();
		}
		property_specifiers();
		d_stack.pop(); 
}

void Parser::record_operator_definition() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_record_operator_definition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_class,__FUNCTION__);
		addTerminal(); 
		operator_definition();
		d_stack.pop(); 
}

void Parser::operator_definition() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_operator_definition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_operator,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_ColonEq || la->kind == _T_explicit) {
			assignment_operator_definition();
		} else if (StartOf(23)) {
			arithmetic_operator_definition();
		} else if (StartOf(24)) {
			comparison_operator_definition();
		} else if (StartOf(25)) {
			logical_operator_definition();
		} else if (la->kind == _T_dec || la->kind == _T_enumerator || la->kind == _T_inc) {
			other_operator_definition();
		} else SynErr(203,__FUNCTION__);
		if (StartOf(5)) {
			result_identifier();
		}
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		result_type();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		subroutine_block();
		d_stack.pop(); 
}

void Parser::formal_parameter_list() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_formal_parameter_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		parameter_declaration();
		while (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
			parameter_declaration();
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::result_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_result_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		type_();
		d_stack.pop(); 
}

void Parser::variable_modifiers() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_variable_modifiers, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		variable_modifier_();
		while (StartOf(10)) {
			variable_modifier_();
		}
		d_stack.pop(); 
}

void Parser::variable_modifier_() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_variable_modifier_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_absolute) {
			Get();
			addTerminal(); 
			expression();
		} else if (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
			if (la->kind == _T_export) {
				Get();
				addTerminal(); 
			} else if (la->kind == _T_cvar) {
				Get();
				addTerminal(); 
			} else if (la->kind == _T_external) {
				Get();
				addTerminal(); 
				if (la->kind == _T_Hash || la->kind == _T_quoted_string) {
					string_constant();
				}
				if (la->kind == _T_name) {
					Get();
					addTerminal(); 
					string_constant();
				}
			} else SynErr(204,__FUNCTION__);
		} else if (StartOf(4)) {
			hint_directive();
		} else SynErr(205,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::property_interface() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_property_interface, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Lbrack) {
			property_parameter_list();
		}
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		type_name();
		if (la->kind == _T_index) {
			Get();
			addTerminal(); 
			integer_constant();
		}
		d_stack.pop(); 
}

void Parser::property_specifiers() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_property_specifiers, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_read) {
			read_specifier();
		}
		if (la->kind == _T_write) {
			write_specifier();
		}
		if (la->kind == _T_default || la->kind == _T_nodefault) {
			default_specifier();
		}
		d_stack.pop(); 
}

void Parser::property_parameter_list() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_property_parameter_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lbrack,__FUNCTION__);
		addTerminal(); 
		parameter_declaration();
		while (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
			parameter_declaration();
		}
		Expect(_T_Rbrack,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::parameter_declaration() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_parameter_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(5)) {
			value_parameter();
		} else if (la->kind == _T_var) {
			variable_parameter();
		} else if (la->kind == _T_out) {
			out_parameter();
		} else if (la->kind == _T_const) {
			constant_parameter();
		} else SynErr(206,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::read_specifier() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_read_specifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_read,__FUNCTION__);
		addTerminal(); 
		field_or_function();
		d_stack.pop(); 
}

void Parser::write_specifier() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_write_specifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_write,__FUNCTION__);
		addTerminal(); 
		field_or_procedure();
		d_stack.pop(); 
}

void Parser::default_specifier() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_default_specifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_default) {
			Get();
			addTerminal(); 
			if (StartOf(13)) {
				constant();
			}
		} else if (la->kind == _T_nodefault) {
			Get();
			addTerminal(); 
		} else SynErr(207,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::field_or_function() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_field_or_function, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		d_stack.pop(); 
}

void Parser::field_or_procedure() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_field_or_procedure, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		d_stack.pop(); 
}

void Parser::heritage() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_heritage, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		type_name();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::component_list() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_component_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_private || la->kind == _T_protected || la->kind == _T_public) {
			object_visibility_specifier();
		}
		while (la->kind == _T_const) {
			const_definition();
		}
		while (StartOf(26)) {
			field_definition();
		}
		while (StartOf(27)) {
			method_definition();
		}
		d_stack.pop(); 
}

void Parser::object_visibility_specifier() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_object_visibility_specifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_private) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_protected) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_public) {
			Get();
			addTerminal(); 
		} else SynErr(208,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::const_definition() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_const_definition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_const,__FUNCTION__);
		addTerminal(); 
		identifier();
		Expect(_T_Eq,__FUNCTION__);
		addTerminal(); 
		constant_expression();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::field_definition() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_field_definition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_class || la->kind == _T_var) {
			if (la->kind == _T_class) {
				Get();
				addTerminal(); 
			}
			Expect(_T_var,__FUNCTION__);
			addTerminal(); 
		}
		identifier_list();
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		type_();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_static) {
			Get();
			addTerminal(); 
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::method_definition() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_method_definition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_class) {
			Get();
			addTerminal(); 
		}
		if (la->kind == _T_function || la->kind == _T_procedure) {
			func_proc_header();
		} else if (la->kind == _T_constructor) {
			constructor_header();
		} else if (la->kind == _T_destructor) {
			destructor_header();
		} else SynErr(209,__FUNCTION__);
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		method_directives();
		d_stack.pop(); 
}

void Parser::constant_expression() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_constant_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}

void Parser::constructor_header() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_constructor_header, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_constructor,__FUNCTION__);
		addTerminal(); 
		identifier();
		if (la->kind == _T_Dot) {
			Get();
			addTerminal(); 
			identifier();
		}
		formal_parameter_list();
		d_stack.pop(); 
}

void Parser::subroutine_block() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_subroutine_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(28)) {
			block();
		} else if (la->kind == _T_external) {
			external_directive();
		} else if (la->kind == _T_assembler) {
			asm_block();
		} else if (la->kind == _T_forward) {
			Get();
			addTerminal(); 
		} else SynErr(210,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::destructor_header() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_destructor_header, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_destructor,__FUNCTION__);
		addTerminal(); 
		identifier();
		if (la->kind == _T_Dot) {
			Get();
			addTerminal(); 
			identifier();
		}
		formal_parameter_list();
		d_stack.pop(); 
}

void Parser::method_directives() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_method_directives, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_virtual) {
			Get();
			addTerminal(); 
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			if (la->kind == _T_abstract) {
				Get();
				addTerminal(); 
				Expect(_T_Semi,__FUNCTION__);
				addTerminal(); 
			}
		}
		if (StartOf(6)) {
			call_modifiers();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::heritage2() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_heritage2, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		type_name();
		implemented_interfaces();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::component_list2() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_component_list2, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(29)) {
			class_visibility_specifier();
		}
		while (StartOf(5)) {
			field_definition2();
		}
		while (StartOf(30)) {
			class_part();
		}
		d_stack.pop(); 
}

void Parser::implemented_interfaces() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_implemented_interfaces, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			identifier();
		}
		d_stack.pop(); 
}

void Parser::class_visibility_specifier() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_class_visibility_specifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_public) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_published) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_private || la->kind == _T_protected || la->kind == _T_strict) {
			if (la->kind == _T_strict) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _T_private) {
				Get();
				addTerminal(); 
			} else if (la->kind == _T_protected) {
				Get();
				addTerminal(); 
			} else SynErr(211,__FUNCTION__);
		} else SynErr(212,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::field_definition2() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_field_definition2, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier_list();
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		type_();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_static) {
			Get();
			addTerminal(); 
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::class_part() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_class_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_const) {
			constant_declaration_part();
		} else if (la->kind == _T_type) {
			type_declaration_part();
		} else if (StartOf(31)) {
			if (la->kind == _T_class) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _T_var) {
				variable_declaration_part();
			} else if (StartOf(9)) {
				method_definition2();
			} else if (la->kind == _T_property) {
				property_definition2();
			} else SynErr(213,__FUNCTION__);
		} else SynErr(214,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::method_definition2() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_method_definition2, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_function || la->kind == _T_procedure) {
			func_proc_header();
		} else if (la->kind == _T_constructor) {
			constructor_header();
		} else if (la->kind == _T_destructor) {
			destructor_header();
		} else SynErr(215,__FUNCTION__);
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		method_directives2();
		if (StartOf(6)) {
			call_modifiers();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::property_definition2() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_property_definition2, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_property,__FUNCTION__);
		addTerminal(); 
		identifier();
		if (la->kind == _T_Colon || la->kind == _T_Lbrack) {
			property_interface();
		}
		property_specifiers2();
		hintdirectives();
		d_stack.pop(); 
}

void Parser::method_directives2() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_method_directives2, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(32)) {
			if (la->kind == _T_dynamic || la->kind == _T_virtual) {
				if (la->kind == _T_virtual) {
					Get();
					addTerminal(); 
				} else {
					Get();
					addTerminal(); 
				}
				if (la->kind == _T_Semi) {
					Get();
					addTerminal(); 
					Expect(_T_abstract,__FUNCTION__);
					addTerminal(); 
				}
			} else if (la->kind == _T_override) {
				Get();
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
				if (StartOf(33)) {
					integer_constant();
				} else if (la->kind == _T_Hash || la->kind == _T_quoted_string) {
					string_constant();
				} else SynErr(216,__FUNCTION__);
			}
		}
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::property_specifiers2() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_property_specifiers2, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_read) {
			read_specifier();
		}
		if (la->kind == _T_implements || la->kind == _T_write) {
			if (la->kind == _T_write) {
				write_specifier();
			} else {
				implements_specifier();
			}
		}
		if (la->kind == _T_default || la->kind == _T_nodefault) {
			default_specifier();
		}
		if (la->kind == _T_stored) {
			stored_specifier();
		}
		if (la->kind == _T_Semi) {
			defaultarraypropertyspecifier();
		}
		d_stack.pop(); 
}

void Parser::implements_specifier() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_implements_specifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_implements,__FUNCTION__);
		addTerminal(); 
		identifier();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			identifier();
		}
		d_stack.pop(); 
}

void Parser::stored_specifier() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_stored_specifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_stored,__FUNCTION__);
		addTerminal(); 
		if (StartOf(13)) {
			constant();
		} else if (StartOf(5)) {
			identifier();
		} else SynErr(217,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::defaultarraypropertyspecifier() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_defaultarraypropertyspecifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		Expect(_T_default,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::guid() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_guid, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lbrack,__FUNCTION__);
		addTerminal(); 
		string_constant();
		Expect(_T_Rbrack,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::template_list() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_template_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier_list2();
		while (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
			identifier_list2();
		}
		d_stack.pop(); 
}

void Parser::generic_type_() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_generic_type_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_class: {
			class_type();
			break;
		}
		case _T_object: {
			object_type();
			break;
		}
		case _T_interface: {
			interface_type();
			break;
		}
		case _T_function: case _T_procedure: {
			procedural_type();
			break;
		}
		case _T_record: {
			record_type();
			break;
		}
		case _T_array: {
			array_type();
			break;
		}
		default: SynErr(218,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::identifier_list2() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_identifier_list2, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier_list();
		if (la->kind == _T_Colon) {
			Get();
			addTerminal(); 
			if (StartOf(5)) {
				type_name();
				while (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					type_name();
				}
			} else if (la->kind == _T_class) {
				Get();
				addTerminal(); 
			} else if (la->kind == _T_interface) {
				Get();
				addTerminal(); 
			} else if (la->kind == _T_object) {
				Get();
				addTerminal(); 
			} else if (la->kind == _T_record) {
				Get();
				addTerminal(); 
			} else SynErr(219,__FUNCTION__);
		}
		d_stack.pop(); 
}

void Parser::type_name_list() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_type_name_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		type_name();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			type_name();
		}
		d_stack.pop(); 
}

void Parser::base_helper() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_base_helper, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		d_stack.pop(); 
}

void Parser::helper_component_list() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_helper_component_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(27)) {
			method_definition();
		} else if (StartOf(5)) {
			property_definition();
		} else SynErr(220,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::simple_expression() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_simple_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		term();
		while (StartOf(34)) {
			adop();
			term();
		}
		d_stack.pop(); 
}

void Parser::relop() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_relop, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Lt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Leq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Gt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Geq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Eq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_LtGt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_in: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_is: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(221,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::term() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_term, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		factor();
		while (StartOf(35)) {
			mulop();
			factor();
		}
		d_stack.pop(); 
}

void Parser::adop() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_adop, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Plus) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Minus) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_or) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_xor) {
			Get();
			addTerminal(); 
		} else SynErr(222,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::factor() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_factor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Lpar: {
			Get();
			addTerminal(); 
			expression();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_abstract: case _T_alias: case _T_ansistring: case _T_assembler: case _T_at: case _T_bitpacked: case _T_cdecl: case _T_cppdecl: case _T_cvar: case _T_dec: case _T_default: case _T_deprecated: case _T_dynamic: case _T_enumerator: case _T_experimental: case _T_explicit: case _T_export: case _T_external: case _T_forward: case _T_generic: case _T_hardfloat: case _T_helper: case _T_implements: case _T_inc: case _T_index: case _T_inline: case _T_interrupt: case _T_iocheck: case _T_local: case _T_message: case _T_ms_abi_cdecl: case _T_ms_abi_default: case _T_mwpascal: case _T_name: case _T_nested: case _T_nodefault: case _T_noreturn: case _T_nostackframe: case _T_otherwise: case _T_overload: case _T_override: case _T_pascal: case _T_platform: case _T_private: case _T_protected: case _T_public: case _T_published: case _T_read: case _T_register: case _T_safecall: case _T_saveregisters: case _T_sealed: case _T_softfloat: case _T_specialize: case _T_static: case _T_stdcall: case _T_stored: case _T_strict: case _T_sysv_abi_cdecl: case _T_sysv_abi_default: case _T_unimplemented: case _T_varargs: case _T_vectorcall: case _T_virtual: case _T_write: case _T_ident: {
			varref_or_funcall_or_constid_or_cast();
			break;
		}
		case _T_Hash: case _T_nil: case _T_unsigned_real: case _T_decimal_int: case _T_hex_int: case _T_octal_int: case _T_binary_int: case _T_quoted_string: {
			unsigned_constant();
			break;
		}
		case _T_not: {
			Get();
			addTerminal(); 
			factor();
			break;
		}
		case _T_Plus: case _T_Minus: {
			sign();
			factor();
			break;
		}
		case _T_Lbrack: {
			set_constructor();
			break;
		}
		case _T_At: {
			address_factor();
			break;
		}
		default: SynErr(223,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::mulop() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_mulop, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Star: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Slash: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_div: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_mod: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_and: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_shl: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_shr: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_as: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(224,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::varref_or_funcall_or_constid_or_cast() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_varref_or_funcall_or_constid_or_cast, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		if (la->kind == _T_Dot) {
			Get();
			addTerminal(); 
			identifier();
		}
		if (la->kind == _T_Lpar) {
			actual_parameter_list();
		}
		d_stack.pop(); 
}

void Parser::unsigned_constant() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_unsigned_constant, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(14)) {
			unsigned_number();
		} else if (la->kind == _T_Hash || la->kind == _T_quoted_string) {
			character_string();
		} else if (la->kind == _T_nil) {
			Get();
			addTerminal(); 
		} else SynErr(225,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::sign() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_sign, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Plus) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Minus) {
			Get();
			addTerminal(); 
		} else SynErr(226,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::set_constructor() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_set_constructor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lbrack,__FUNCTION__);
		addTerminal(); 
		if (StartOf(36)) {
			set_group();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				set_group();
			}
		}
		Expect(_T_Rbrack,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::address_factor() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_address_factor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_At,__FUNCTION__);
		addTerminal(); 
		identifier();
		if (la->kind == _T_Dot) {
			Get();
			addTerminal(); 
			identifier();
		}
		d_stack.pop(); 
}

void Parser::actual_parameter_list() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_actual_parameter_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (StartOf(36)) {
			expression();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				expression();
			}
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::unsigned_number() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_unsigned_number, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(33)) {
			unsigned_integer();
		} else if (la->kind == _T_unsigned_real) {
			Get();
			addTerminal(); 
		} else SynErr(227,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::character_string() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_character_string, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_quoted_string) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Hash) {
			control_string();
		} else SynErr(228,__FUNCTION__);
		while (la->kind == _T_Hash || la->kind == _T_quoted_string) {
			if (la->kind == _T_quoted_string) {
				Get();
				addTerminal(); 
			} else {
				control_string();
			}
		}
		d_stack.pop(); 
}

void Parser::set_group() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_set_group, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		if (la->kind == _T_2Dot) {
			Get();
			addTerminal(); 
			expression();
		}
		d_stack.pop(); 
}

void Parser::simple_statement() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_simple_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(5)) {
			assig_or_call();
		} else if (la->kind == _T_goto) {
			goto_statement();
		} else if (la->kind == _T_raise) {
			raise_statement();
		} else SynErr(229,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::structured_statement() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_structured_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_begin) {
			compound_statement();
		} else if (la->kind == _T_case || la->kind == _T_if) {
			conditional_statement();
		} else if (la->kind == _T_for || la->kind == _T_repeat || la->kind == _T_while) {
			repetitive_statement();
			with_statement();
		} else if (la->kind == _T_try) {
			try_statement();
		} else SynErr(230,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::asm_statement() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_asm_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_asm,__FUNCTION__);
		addTerminal(); 
		Expect(_T_end,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Lbrack) {
			register_list();
		}
		d_stack.pop(); 
}

void Parser::assig_or_call() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_assig_or_call, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		if (la->kind == _T_Dot) {
			Get();
			addTerminal(); 
			identifier();
		}
		if (StartOf(37)) {
			assigop();
			expression();
		} else if (StartOf(38)) {
			if (la->kind == _T_Lpar) {
				actual_parameter_list();
			}
		} else SynErr(231,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::goto_statement() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_goto_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_goto,__FUNCTION__);
		addTerminal(); 
		label_def();
		d_stack.pop(); 
}

void Parser::raise_statement() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_raise_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_raise,__FUNCTION__);
		addTerminal(); 
		if (StartOf(5)) {
			exception_instance();
			if (la->kind == _T_at) {
				exception_address();
			}
		}
		d_stack.pop(); 
}

void Parser::assigop() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_assigop, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_ColonEq) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_PlusEq) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_MinusEq) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_StarEq) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_SlashEq) {
			Get();
			addTerminal(); 
		} else SynErr(232,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::conditional_statement() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_conditional_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_case) {
			case_statement();
		} else if (la->kind == _T_if) {
			if_statement();
		} else SynErr(233,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::repetitive_statement() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_repetitive_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_for) {
			for_statement();
		} else if (la->kind == _T_repeat) {
			repeat_statement();
		} else if (la->kind == _T_while) {
			while_statement();
		} else SynErr(234,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::with_statement() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_with_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_with,__FUNCTION__);
		addTerminal(); 
		variable_reference();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			variable_reference();
		}
		d_stack.pop(); 
}

void Parser::try_statement() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_try_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_try,__FUNCTION__);
		addTerminal(); 
		statement_list();
		if (la->kind == _T_except) {
			Get();
			addTerminal(); 
			exceptionhandlers();
		} else if (la->kind == _T_finally) {
			Get();
			addTerminal(); 
			statement_list();
		} else SynErr(235,__FUNCTION__);
		Expect(_T_end,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::case_statement() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_case_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_case,__FUNCTION__);
		addTerminal(); 
		expression();
		Expect(_T_of,__FUNCTION__);
		addTerminal(); 
		case_part();
		while (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
			case_part();
		}
		if (la->kind == _T_else || la->kind == _T_otherwise) {
			else_part();
		}
		if (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
		}
		Expect(_T_end,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::if_statement() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_if_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_if,__FUNCTION__);
		addTerminal(); 
		expression();
		Expect(_T_then,__FUNCTION__);
		addTerminal(); 
		statement();
		if (la->kind == _T_else) {
			Get();
			addTerminal(); 
			statement();
		}
		d_stack.pop(); 
}

void Parser::for_statement() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_for_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_for,__FUNCTION__);
		addTerminal(); 
		control_variable();
		if (la->kind == _T_ColonEq) {
			Get();
			addTerminal(); 
			initial_value();
			if (la->kind == _T_to) {
				Get();
				addTerminal(); 
			} else if (la->kind == _T_downto) {
				Get();
				addTerminal(); 
			} else SynErr(236,__FUNCTION__);
			final_value();
		} else if (la->kind == _T_in) {
			Get();
			addTerminal(); 
			enumerable();
		} else SynErr(237,__FUNCTION__);
		Expect(_T_do,__FUNCTION__);
		addTerminal(); 
		statement();
		d_stack.pop(); 
}

void Parser::repeat_statement() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_repeat_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_repeat,__FUNCTION__);
		addTerminal(); 
		statement_list();
		Expect(_T_until,__FUNCTION__);
		addTerminal(); 
		expression();
		d_stack.pop(); 
}

void Parser::while_statement() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_while_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_while,__FUNCTION__);
		addTerminal(); 
		expression();
		Expect(_T_do,__FUNCTION__);
		addTerminal(); 
		statement();
		d_stack.pop(); 
}

void Parser::statement_list() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_statement_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		statement();
		while (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
			statement();
		}
		d_stack.pop(); 
}

void Parser::case_part() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_case_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		case_range();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			case_range();
		}
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		statement();
		d_stack.pop(); 
}

void Parser::else_part() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_else_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_else) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_otherwise) {
			Get();
			addTerminal(); 
		} else SynErr(238,__FUNCTION__);
		statement_list();
		d_stack.pop(); 
}

void Parser::case_range() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_case_range, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		constant();
		if (la->kind == _T_2Dot) {
			Get();
			addTerminal(); 
			constant();
		}
		d_stack.pop(); 
}

void Parser::control_variable() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_control_variable, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		variable_identifier();
		d_stack.pop(); 
}

void Parser::initial_value() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_initial_value, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}

void Parser::final_value() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_final_value, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}

void Parser::enumerable() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_enumerable, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Lpar) {
			enumerated_type();
		} else if (StartOf(5)) {
			identifier();
		} else if (la->kind == _T_Lbrack) {
			set_constructor();
		} else SynErr(239,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::variable_identifier() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_variable_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		d_stack.pop(); 
}

void Parser::variable_reference() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_variable_reference, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		d_stack.pop(); 
}

void Parser::register_list() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_register_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lbrack,__FUNCTION__);
		addTerminal(); 
		string_constant();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			string_constant();
		}
		Expect(_T_Rbrack,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::procedure_header() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_procedure_header, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_procedure,__FUNCTION__);
		addTerminal(); 
		identifier();
		if (la->kind == _T_Dot) {
			Get();
			addTerminal(); 
			identifier();
		}
		formal_parameter_list();
		if (la->kind == _T_Semi) {
			modifiers();
		}
		hintdirectives();
		d_stack.pop(); 
}

void Parser::modifiers() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_modifiers, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		modifier();
		while (la->kind == _T_Semi) {
			modifier();
		}
		d_stack.pop(); 
}

void Parser::external_directive() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_external_directive, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_external,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Hash || la->kind == _T_quoted_string) {
			string_constant();
			if (la->kind == _T_index || la->kind == _T_name) {
				if (la->kind == _T_name) {
					Get();
					addTerminal(); 
					string_constant();
				} else {
					Get();
					addTerminal(); 
					integer_constant();
				}
			}
		}
		d_stack.pop(); 
}

void Parser::asm_block() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_asm_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_assembler,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		declaration_part();
		d_stack.pop(); 
}

void Parser::function_header() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_function_header, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_function,__FUNCTION__);
		addTerminal(); 
		identifier();
		if (la->kind == _T_Dot) {
			Get();
			addTerminal(); 
			identifier();
		}
		formal_parameter_list();
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		result_type();
		if (la->kind == _T_Semi) {
			modifiers();
		}
		hintdirectives();
		d_stack.pop(); 
}

void Parser::value_parameter() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_value_parameter, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier_list();
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_array) {
			Get();
			addTerminal(); 
			Expect(_T_of,__FUNCTION__);
			addTerminal(); 
		}
		parameter_type();
		if (la->kind == _T_Eq) {
			Get();
			addTerminal(); 
			default_parameter_value();
		}
		d_stack.pop(); 
}

void Parser::variable_parameter() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_variable_parameter, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_var,__FUNCTION__);
		addTerminal(); 
		identifier_list();
		if (la->kind == _T_Colon) {
			Get();
			addTerminal(); 
			if (la->kind == _T_array) {
				Get();
				addTerminal(); 
				Expect(_T_of,__FUNCTION__);
				addTerminal(); 
			}
			type_name();
		}
		d_stack.pop(); 
}

void Parser::out_parameter() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_out_parameter, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_out,__FUNCTION__);
		addTerminal(); 
		identifier_list();
		if (la->kind == _T_Colon) {
			Get();
			addTerminal(); 
			if (la->kind == _T_array) {
				Get();
				addTerminal(); 
				Expect(_T_of,__FUNCTION__);
				addTerminal(); 
			}
			type_name();
		}
		d_stack.pop(); 
}

void Parser::constant_parameter() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_constant_parameter, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_const,__FUNCTION__);
		addTerminal(); 
		identifier_list();
		if (la->kind == _T_Colon) {
			Get();
			addTerminal(); 
			if (la->kind == _T_array) {
				Get();
				addTerminal(); 
				Expect(_T_of,__FUNCTION__);
				addTerminal(); 
			}
			type_name();
		}
		d_stack.pop(); 
}

void Parser::parameter_type() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_parameter_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		type_name();
		d_stack.pop(); 
}

void Parser::default_parameter_value() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_default_parameter_value, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}

void Parser::modifier() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_modifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		switch (la->kind) {
		case _T_public: {
			Get();
			addTerminal(); 
			if (la->kind == _T_name) {
				Get();
				addTerminal(); 
				string_constant();
			}
			break;
		}
		case _T_export: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_alias: {
			Get();
			addTerminal(); 
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
			string_constant();
			break;
		}
		case _T_interrupt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_noreturn: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_iocheck: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_cdecl: case _T_cppdecl: case _T_hardfloat: case _T_inline: case _T_local: case _T_ms_abi_cdecl: case _T_ms_abi_default: case _T_mwpascal: case _T_nostackframe: case _T_overload: case _T_pascal: case _T_register: case _T_safecall: case _T_saveregisters: case _T_softfloat: case _T_stdcall: case _T_sysv_abi_cdecl: case _T_sysv_abi_default: case _T_varargs: case _T_vectorcall: {
			call_modifiers2();
			break;
		}
		default: SynErr(240,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::call_modifiers2() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_call_modifiers2, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_cdecl: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_cppdecl: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_hardfloat: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_inline: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_local: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_mwpascal: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_ms_abi_default: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_ms_abi_cdecl: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_nostackframe: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_overload: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_pascal: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_register: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_safecall: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_saveregisters: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_softfloat: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_stdcall: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_sysv_abi_default: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_sysv_abi_cdecl: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_vectorcall: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_varargs: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(241,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::assignment_operator_definition() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_assignment_operator_definition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_ColonEq) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_explicit) {
			Get();
			addTerminal(); 
		} else SynErr(242,__FUNCTION__);
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		value_parameter();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::arithmetic_operator_definition() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_arithmetic_operator_definition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Plus: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Minus: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Star: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Slash: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_2Star: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_GtLt: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(243,__FUNCTION__); break;
		}
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		parameter_list();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::comparison_operator_definition() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_comparison_operator_definition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Eq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Lt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Leq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Gt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Geq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_LtGt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_in: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(244,__FUNCTION__); break;
		}
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		parameter_list();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::logical_operator_definition() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_logical_operator_definition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_and) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_or) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_xor) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_not) {
			Get();
			addTerminal(); 
		} else SynErr(245,__FUNCTION__);
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		parameter_list();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::other_operator_definition() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_other_operator_definition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_enumerator) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_inc) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_dec) {
			Get();
			addTerminal(); 
		} else SynErr(246,__FUNCTION__);
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		parameter_list();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::result_identifier() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_result_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		d_stack.pop(); 
}

void Parser::parameter_list() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_parameter_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		parameter_declaration();
		while (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
			parameter_declaration();
		}
		d_stack.pop(); 
}

void Parser::exception_instance() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_exception_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		d_stack.pop(); 
}

void Parser::exception_address() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_exception_address, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_at,__FUNCTION__);
		addTerminal(); 
		address_expression();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			address_expression();
		}
		d_stack.pop(); 
}

void Parser::address_expression() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_address_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}

void Parser::exceptionhandlers() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_exceptionhandlers, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(39)) {
			if (StartOf(40)) {
				statement_list();
			} else {
				exception_handler();
				while (la->kind == _T_Semi) {
					Get();
					addTerminal(); 
					exception_handler();
				}
				Expect(_T_else,__FUNCTION__);
				addTerminal(); 
				statement_list();
			}
		}
		d_stack.pop(); 
}

void Parser::exception_handler() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_exception_handler, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_on,__FUNCTION__);
		addTerminal(); 
		if (peek(2) == _T_Colon ) {
			identifier();
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
		}
		type_name();
		Expect(_T_do,__FUNCTION__);
		addTerminal(); 
		statement();
		d_stack.pop(); 
}

void Parser::control_string() {
		Fp::SynTree* n = new Fp::SynTree( Fp::SynTree::R_control_string, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Hash,__FUNCTION__);
		addTerminal(); 
		unsigned_integer();
		d_stack.pop(); 
}




// If the user declared a method Init and a mehtod Destroy they should
// be called in the contructur and the destructor respctively.
//
// The following templates are used to recognize if the user declared
// the methods Init and Destroy.

template<typename T>
struct ParserInitExistsRecognizer {
	template<typename U, void (U::*)() = &U::Init>
	struct ExistsIfInitIsDefinedMarker{};

	struct InitIsMissingType {
		char dummy1;
	};
	
	struct InitExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static InitIsMissingType is_here(...);

	// exist only if ExistsIfInitIsDefinedMarker is defined
	template<typename U>
	static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

	enum { InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType)) };
};

template<typename T>
struct ParserDestroyExistsRecognizer {
	template<typename U, void (U::*)() = &U::Destroy>
	struct ExistsIfDestroyIsDefinedMarker{};

	struct DestroyIsMissingType {
		char dummy1;
	};
	
	struct DestroyExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static DestroyIsMissingType is_here(...);

	// exist only if ExistsIfDestroyIsDefinedMarker is defined
	template<typename U>
	static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

	enum { DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType)) };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller {
	static void CallInit(T *t) {
		// nothing to do
	}
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true> {
	static void CallInit(T *t) {
		t->Init();
	}
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller {
	static void CallDestroy(T *t) {
		// nothing to do
	}
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true> {
	static void CallDestroy(T *t) {
		t->Destroy();
	}
};

void Parser::Parse() {
	d_cur = Token();
	d_next = Token();
	Get();
	FreePascal();
	Expect(0,__FUNCTION__);
}

Parser::Parser(PpLexer *scanner) {
	maxT = 182;

	ParserInitCaller<Parser>::CallInit(this);
	la = &d_dummy;
	minErrDist = 2;
	errDist = minErrDist;
	this->scanner = scanner;
}

bool Parser::StartOf(int s) {
	const bool T = true;
	const bool x = false;

	static bool set[41][184] = {
		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, T,x,x,x, T,T,x,T, x,T,x,x, x,T,T,T, T,T,x,x, x,x,T,x, x,T,x,T, T,T,x,T, x,x,x,x, T,x,T,T, T,T,x,x, T,x,T,T, x,T,x,T, T,x,x,x, T,T,x,T, T,T,T,T, x,T,T,T, x,x,x,x, x,x,T,x, T,T,x,T, T,T,x,x, x,T,T,T, T,T,x,T, x,x,T,T, T,x,x,x, T,T,T,T, T,T,x,T, T,x,x,x, x,x,T,x, x,x,x,T, T,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, T,x,x,x, T,T,x,T, x,T,x,x, x,T,T,T, T,T,x,x, x,x,T,x, x,T,x,T, T,T,x,T, x,x,x,x, T,x,T,x, T,T,x,x, T,x,T,T, x,T,x,T, T,x,x,x, T,T,x,T, T,T,T,T, x,T,T,T, x,x,x,x, x,x,T,x, T,T,x,T, T,T,x,x, x,T,T,T, x,T,x,T, x,x,T,T, T,x,x,x, T,T,T,T, T,T,x,T, T,x,x,x, x,x,T,x, x,x,x,T, T,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,T,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, T,x,x,x, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x, x,x,T,x, T,T,x,T, T,T,T,T, x,T,x,x, T,T,T,x, T,T,x,x, T,x,T,T, T,T,x,T, T,x,T,x, T,T,x,T, T,T,T,T, x,T,T,T, x,x,x,x, x,x,T,x, T,T,x,T, T,T,T,x, x,T,T,T, x,T,x,T, x,T,T,T, T,x,x,x, T,T,T,T, T,T,x,T, T,x,T,x, x,T,T,x, x,x,T,T, T,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, T,x,x,x, T,T,x,T, x,T,x,x, x,T,T,T, T,T,x,x, x,x,T,x, x,T,x,T, T,T,x,T, x,x,x,x, T,x,T,x, T,T,x,x, T,x,T,T, x,T,x,T, T,x,x,x, T,T,x,T, T,T,T,T, x,T,T,T, x,x,x,x, x,x,T,x, T,T,x,T, T,T,x,x, x,T,T,T, x,T,x,T, x,x,T,T, T,x,x,x, T,T,T,T, T,T,T,T, T,x,x,x, x,T,T,x, x,x,x,T, T,T,x,x, T,x,x,x, x,x,x,T, T,T,T,T, T,T,x,x, x,x,x,x},
		{x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,T,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, T,x,x,x, T,T,x,T, x,T,T,x, T,T,T,T, T,T,T,x, x,x,T,x, x,T,x,T, T,T,x,T, x,x,x,x, T,T,T,x, T,T,x,x, T,x,T,T, x,T,x,T, T,x,x,x, T,T,x,T, T,T,T,T, x,T,T,T, x,x,x,x, x,x,T,x, T,T,x,T, T,T,T,x, x,T,T,T, x,T,x,T, x,x,T,T, T,x,x,x, T,T,T,T, T,T,x,T, T,x,x,x, x,x,T,x, x,x,x,T, T,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, T,x,x,x, T,T,x,T, x,T,x,x, x,T,T,T, T,T,x,x, x,x,T,x, x,T,x,T, T,T,x,T, x,x,x,x, T,x,T,x, T,T,x,x, T,x,T,T, x,T,x,T, T,x,x,x, T,T,x,T, T,T,T,T, x,T,T,T, x,x,x,x, x,x,T,x, T,T,x,T, T,T,x,x, x,T,T,T, x,T,x,T, x,x,T,T, T,x,x,x, T,T,T,T, T,T,x,T, T,x,x,x, x,x,T,x, x,x,x,T, T,T,x,x, T,x,x,x, x,x,x,T, T,T,T,T, T,T,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, T,x,x,x, T,T,x,T, x,T,T,T, T,T,T,T, T,T,T,x, x,x,T,x, T,T,x,T, T,T,x,T, x,x,x,x, T,T,T,x, T,T,x,x, T,x,T,T, x,T,x,T, T,x,x,x, T,T,x,T, T,T,T,T, x,T,T,T, x,x,x,x, x,x,T,x, T,T,x,T, T,T,T,x, T,T,T,T, x,T,x,T, x,x,T,T, T,x,x,x, T,T,T,T, T,T,x,T, T,x,x,x, x,T,T,x, x,x,T,T, T,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, T,x,x,x, T,T,x,T, T,T,T,x, x,T,T,T, T,T,x,x, x,x,T,x, T,T,x,T, T,T,x,T, x,x,x,x, T,T,T,x, T,T,x,x, T,x,T,T, x,T,x,T, T,x,x,x, T,T,x,T, T,T,T,T, x,T,T,T, x,x,x,x, x,x,T,x, T,T,x,T, T,T,T,x, x,T,T,T, x,T,x,T, x,x,T,T, T,x,x,x, T,T,T,T, T,T,x,T, T,x,x,x, x,x,T,x, x,x,x,T, T,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, T,x,x,x, T,T,x,T, x,T,T,T, T,T,T,T, T,T,T,x, x,x,T,x, T,T,x,T, T,T,x,T, x,x,x,x, T,T,T,x, T,T,x,x, T,x,T,T, x,T,x,T, T,x,x,x, T,T,x,T, T,T,T,T, x,T,T,T, x,x,x,x, x,x,T,x, T,T,x,T, T,T,T,x, x,T,T,T, x,T,x,T, x,x,T,T, T,x,x,x, T,T,T,T, T,T,x,T, T,x,x,x, x,x,T,x, x,x,T,T, T,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, T,x,x,x, T,T,x,T, x,T,T,T, T,T,T,T, T,T,T,x, x,x,T,x, T,T,x,T, T,T,x,T, x,x,x,x, T,T,T,x, T,T,x,x, T,x,T,T, x,T,x,T, T,x,x,x, T,T,x,T, T,T,T,T, x,T,T,T, x,x,x,x, x,x,T,x, T,T,x,T, T,T,T,x, T,T,T,T, x,T,x,T, x,x,T,T, T,x,x,x, T,T,T,T, T,T,x,T, T,x,x,x, x,T,T,x, x,x,T,T, T,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, T,x,x,x, T,T,x,T, T,T,x,x, x,T,T,T, T,T,x,x, x,x,T,x, x,T,x,T, T,T,x,T, x,x,x,x, T,x,T,x, T,T,x,x, T,x,T,T, x,T,x,T, T,x,x,x, T,T,x,T, T,T,T,T, x,T,T,T, x,x,x,x, x,x,T,x, T,T,x,T, T,T,x,x, x,T,T,T, x,T,x,T, x,x,T,T, T,x,x,x, T,T,T,T, T,T,x,T, T,x,x,x, x,x,T,x, x,x,x,T, T,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,T,x, T,x,T,x, x,T,x,x, x,T,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, T,x,x,x, T,T,x,T, x,T,T,x, x,T,T,T, T,T,x,x, x,x,T,x, x,T,x,T, T,T,x,T, x,x,x,x, T,x,T,x, T,T,x,x, T,x,T,T, x,T,x,T, T,x,x,x, T,T,x,T, T,T,T,T, x,T,T,T, x,x,x,x, x,x,T,x, T,T,x,T, T,T,x,x, x,T,T,T, x,T,x,T, x,x,T,T, T,x,x,x, T,T,T,T, T,T,x,T, T,x,x,x, x,x,T,x, x,x,T,T, T,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,T, T,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,T,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,T, T,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,T,T, x,x,x,x, x,x,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,T,T,x, T,x,x,x, T,T,x,T, x,T,x,x, x,T,T,T, T,T,x,x, x,x,T,x, x,T,x,T, T,T,x,T, x,x,x,x, T,x,T,x, T,T,x,x, T,x,T,T, x,T,x,T, T,x,x,x, T,T,x,T, T,T,T,T, T,T,T,T, T,x,x,x, x,x,T,x, T,T,x,T, T,T,x,x, x,T,T,T, x,T,x,T, x,x,T,T, T,x,x,x, T,T,T,T, T,T,x,T, T,x,x,x, x,x,T,x, x,x,x,T, T,T,x,x, T,x,x,x, x,x,x,T, T,T,T,T, T,T,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,T,x,T, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,T,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, T,x,x,T, T,T,T,T, T,T,x,x, x,T,T,T, T,T,x,x, x,x,T,x, x,T,x,T, T,T,x,T, x,x,x,T, T,x,T,T, T,T,T,x, T,x,T,T, x,T,x,T, T,x,x,x, T,T,x,T, T,T,T,T, x,T,T,T, x,x,x,T, x,x,T,x, T,T,x,T, T,T,x,x, x,T,T,T, T,T,x,T, T,x,T,T, T,x,x,x, T,T,T,T, T,T,x,T, T,x,x,x, T,x,T,x, x,x,x,T, T,T,T,x, T,x,x,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, T,x,x,T, T,T,T,T, T,T,x,x, x,T,T,T, T,T,x,x, x,x,T,x, x,T,x,T, T,T,x,T, x,x,x,T, T,x,T,T, T,T,T,x, T,x,T,T, x,T,x,T, T,x,x,x, T,T,x,T, T,T,T,T, x,T,T,T, x,x,x,x, x,x,T,x, T,T,x,T, T,T,x,x, x,T,T,T, T,T,x,T, T,x,T,T, T,x,x,x, T,T,T,T, T,T,x,T, T,x,x,x, T,x,T,x, x,x,x,T, T,T,T,x, T,x,x,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x}
	};



	return set[s][la->kind];
}

Parser::~Parser() {
	ParserDestroyCaller<Parser>::CallDestroy(this);
}

void Parser::SynErr(int line, int col, int n, const char* ctx, const QString& str, const QString& path ) {
	QString s;
	QString ctxStr;
	if( ctx )
		ctxStr = QString( " in %1" ).arg(ctx);
    if( n == 0 )
        s = QString("EOF expected%1").arg(ctxStr);
    else if( n < TT_Specials )
        s = QString("'%2' expected%1").arg(ctxStr).arg(tokenTypeString(n));
    else if( n <= TT_Max )
        s = QString("%2 expected%1").arg(ctxStr).arg(tokenTypeString(n));
    else
	switch (n) {
			case 0: s = coco_string_create(L"EOF expected"); break;
			case 1: s = coco_string_create(L"T_Literals_ expected"); break;
			case 2: s = coco_string_create(L"T_Hash expected"); break;
			case 3: s = coco_string_create(L"T_Lpar expected"); break;
			case 4: s = coco_string_create(L"T_Latt expected"); break;
			case 5: s = coco_string_create(L"T_Rpar expected"); break;
			case 6: s = coco_string_create(L"T_Star expected"); break;
			case 7: s = coco_string_create(L"T_Ratt expected"); break;
			case 8: s = coco_string_create(L"T_2Star expected"); break;
			case 9: s = coco_string_create(L"T_StarEq expected"); break;
			case 10: s = coco_string_create(L"T_Plus expected"); break;
			case 11: s = coco_string_create(L"T_PlusEq expected"); break;
			case 12: s = coco_string_create(L"T_Comma expected"); break;
			case 13: s = coco_string_create(L"T_Minus expected"); break;
			case 14: s = coco_string_create(L"T_MinusEq expected"); break;
			case 15: s = coco_string_create(L"T_Dot expected"); break;
			case 16: s = coco_string_create(L"T_2Dot expected"); break;
			case 17: s = coco_string_create(L"T_Slash expected"); break;
			case 18: s = coco_string_create(L"T_SlashEq expected"); break;
			case 19: s = coco_string_create(L"T_Colon expected"); break;
			case 20: s = coco_string_create(L"T_ColonEq expected"); break;
			case 21: s = coco_string_create(L"T_Semi expected"); break;
			case 22: s = coco_string_create(L"T_Lt expected"); break;
			case 23: s = coco_string_create(L"T_Leq expected"); break;
			case 24: s = coco_string_create(L"T_LtGt expected"); break;
			case 25: s = coco_string_create(L"T_Eq expected"); break;
			case 26: s = coco_string_create(L"T_Gt expected"); break;
			case 27: s = coco_string_create(L"T_GtLt expected"); break;
			case 28: s = coco_string_create(L"T_Geq expected"); break;
			case 29: s = coco_string_create(L"T_At expected"); break;
			case 30: s = coco_string_create(L"T_Lbrack expected"); break;
			case 31: s = coco_string_create(L"T_Rbrack expected"); break;
			case 32: s = coco_string_create(L"T_Hat expected"); break;
			case 33: s = coco_string_create(L"T_Lbrace expected"); break;
			case 34: s = coco_string_create(L"T_Rbrace expected"); break;
			case 35: s = coco_string_create(L"T_Keywords_ expected"); break;
			case 36: s = coco_string_create(L"T_absolute expected"); break;
			case 37: s = coco_string_create(L"T_abstract expected"); break;
			case 38: s = coco_string_create(L"T_alias expected"); break;
			case 39: s = coco_string_create(L"T_and expected"); break;
			case 40: s = coco_string_create(L"T_ansistring expected"); break;
			case 41: s = coco_string_create(L"T_array expected"); break;
			case 42: s = coco_string_create(L"T_as expected"); break;
			case 43: s = coco_string_create(L"T_asm expected"); break;
			case 44: s = coco_string_create(L"T_assembler expected"); break;
			case 45: s = coco_string_create(L"T_at expected"); break;
			case 46: s = coco_string_create(L"T_begin expected"); break;
			case 47: s = coco_string_create(L"T_bitpacked expected"); break;
			case 48: s = coco_string_create(L"T_case expected"); break;
			case 49: s = coco_string_create(L"T_cdecl expected"); break;
			case 50: s = coco_string_create(L"T_class expected"); break;
			case 51: s = coco_string_create(L"T_const expected"); break;
			case 52: s = coco_string_create(L"T_constructor expected"); break;
			case 53: s = coco_string_create(L"T_cppdecl expected"); break;
			case 54: s = coco_string_create(L"T_cvar expected"); break;
			case 55: s = coco_string_create(L"T_dec expected"); break;
			case 56: s = coco_string_create(L"T_default expected"); break;
			case 57: s = coco_string_create(L"T_deprecated expected"); break;
			case 58: s = coco_string_create(L"T_destructor expected"); break;
			case 59: s = coco_string_create(L"T_div expected"); break;
			case 60: s = coco_string_create(L"T_do expected"); break;
			case 61: s = coco_string_create(L"T_downto expected"); break;
			case 62: s = coco_string_create(L"T_dynamic expected"); break;
			case 63: s = coco_string_create(L"T_else expected"); break;
			case 64: s = coco_string_create(L"T_end expected"); break;
			case 65: s = coco_string_create(L"T_enumerator expected"); break;
			case 66: s = coco_string_create(L"T_except expected"); break;
			case 67: s = coco_string_create(L"T_experimental expected"); break;
			case 68: s = coco_string_create(L"T_explicit expected"); break;
			case 69: s = coco_string_create(L"T_export expected"); break;
			case 70: s = coco_string_create(L"T_exports expected"); break;
			case 71: s = coco_string_create(L"T_external expected"); break;
			case 72: s = coco_string_create(L"T_file expected"); break;
			case 73: s = coco_string_create(L"T_finalization expected"); break;
			case 74: s = coco_string_create(L"T_finally expected"); break;
			case 75: s = coco_string_create(L"T_for expected"); break;
			case 76: s = coco_string_create(L"T_forward expected"); break;
			case 77: s = coco_string_create(L"T_function expected"); break;
			case 78: s = coco_string_create(L"T_generic expected"); break;
			case 79: s = coco_string_create(L"T_goto expected"); break;
			case 80: s = coco_string_create(L"T_hardfloat expected"); break;
			case 81: s = coco_string_create(L"T_helper expected"); break;
			case 82: s = coco_string_create(L"T_if expected"); break;
			case 83: s = coco_string_create(L"T_implementation expected"); break;
			case 84: s = coco_string_create(L"T_implements expected"); break;
			case 85: s = coco_string_create(L"T_in expected"); break;
			case 86: s = coco_string_create(L"T_inc expected"); break;
			case 87: s = coco_string_create(L"T_index expected"); break;
			case 88: s = coco_string_create(L"T_initialization expected"); break;
			case 89: s = coco_string_create(L"T_inline expected"); break;
			case 90: s = coco_string_create(L"T_interface expected"); break;
			case 91: s = coco_string_create(L"T_interrupt expected"); break;
			case 92: s = coco_string_create(L"T_iocheck expected"); break;
			case 93: s = coco_string_create(L"T_is expected"); break;
			case 94: s = coco_string_create(L"T_label expected"); break;
			case 95: s = coco_string_create(L"T_library expected"); break;
			case 96: s = coco_string_create(L"T_local expected"); break;
			case 97: s = coco_string_create(L"T_message expected"); break;
			case 98: s = coco_string_create(L"T_mod expected"); break;
			case 99: s = coco_string_create(L"T_ms_abi_cdecl expected"); break;
			case 100: s = coco_string_create(L"T_ms_abi_default expected"); break;
			case 101: s = coco_string_create(L"T_mwpascal expected"); break;
			case 102: s = coco_string_create(L"T_name expected"); break;
			case 103: s = coco_string_create(L"T_nested expected"); break;
			case 104: s = coco_string_create(L"T_nil expected"); break;
			case 105: s = coco_string_create(L"T_nodefault expected"); break;
			case 106: s = coco_string_create(L"T_noreturn expected"); break;
			case 107: s = coco_string_create(L"T_nostackframe expected"); break;
			case 108: s = coco_string_create(L"T_not expected"); break;
			case 109: s = coco_string_create(L"T_object expected"); break;
			case 110: s = coco_string_create(L"T_of expected"); break;
			case 111: s = coco_string_create(L"T_on expected"); break;
			case 112: s = coco_string_create(L"T_operator expected"); break;
			case 113: s = coco_string_create(L"T_or expected"); break;
			case 114: s = coco_string_create(L"T_otherwise expected"); break;
			case 115: s = coco_string_create(L"T_out expected"); break;
			case 116: s = coco_string_create(L"T_overload expected"); break;
			case 117: s = coco_string_create(L"T_override expected"); break;
			case 118: s = coco_string_create(L"T_packed expected"); break;
			case 119: s = coco_string_create(L"T_pascal expected"); break;
			case 120: s = coco_string_create(L"T_platform expected"); break;
			case 121: s = coco_string_create(L"T_private expected"); break;
			case 122: s = coco_string_create(L"T_procedure expected"); break;
			case 123: s = coco_string_create(L"T_program expected"); break;
			case 124: s = coco_string_create(L"T_property expected"); break;
			case 125: s = coco_string_create(L"T_protected expected"); break;
			case 126: s = coco_string_create(L"T_public expected"); break;
			case 127: s = coco_string_create(L"T_published expected"); break;
			case 128: s = coco_string_create(L"T_raise expected"); break;
			case 129: s = coco_string_create(L"T_read expected"); break;
			case 130: s = coco_string_create(L"T_record expected"); break;
			case 131: s = coco_string_create(L"T_register expected"); break;
			case 132: s = coco_string_create(L"T_repeat expected"); break;
			case 133: s = coco_string_create(L"T_resourcestring expected"); break;
			case 134: s = coco_string_create(L"T_safecall expected"); break;
			case 135: s = coco_string_create(L"T_saveregisters expected"); break;
			case 136: s = coco_string_create(L"T_sealed expected"); break;
			case 137: s = coco_string_create(L"T_set expected"); break;
			case 138: s = coco_string_create(L"T_shl expected"); break;
			case 139: s = coco_string_create(L"T_shr expected"); break;
			case 140: s = coco_string_create(L"T_softfloat expected"); break;
			case 141: s = coco_string_create(L"T_specialize expected"); break;
			case 142: s = coco_string_create(L"T_static expected"); break;
			case 143: s = coco_string_create(L"T_stdcall expected"); break;
			case 144: s = coco_string_create(L"T_stored expected"); break;
			case 145: s = coco_string_create(L"T_strict expected"); break;
			case 146: s = coco_string_create(L"T_string expected"); break;
			case 147: s = coco_string_create(L"T_sysv_abi_cdecl expected"); break;
			case 148: s = coco_string_create(L"T_sysv_abi_default expected"); break;
			case 149: s = coco_string_create(L"T_then expected"); break;
			case 150: s = coco_string_create(L"T_threadvar expected"); break;
			case 151: s = coco_string_create(L"T_to expected"); break;
			case 152: s = coco_string_create(L"T_try expected"); break;
			case 153: s = coco_string_create(L"T_type expected"); break;
			case 154: s = coco_string_create(L"T_unimplemented expected"); break;
			case 155: s = coco_string_create(L"T_unit expected"); break;
			case 156: s = coco_string_create(L"T_until expected"); break;
			case 157: s = coco_string_create(L"T_uses expected"); break;
			case 158: s = coco_string_create(L"T_var expected"); break;
			case 159: s = coco_string_create(L"T_varargs expected"); break;
			case 160: s = coco_string_create(L"T_vectorcall expected"); break;
			case 161: s = coco_string_create(L"T_virtual expected"); break;
			case 162: s = coco_string_create(L"T_while expected"); break;
			case 163: s = coco_string_create(L"T_with expected"); break;
			case 164: s = coco_string_create(L"T_write expected"); break;
			case 165: s = coco_string_create(L"T_xor expected"); break;
			case 166: s = coco_string_create(L"T_Specials_ expected"); break;
			case 167: s = coco_string_create(L"T_address_constant expected"); break;
			case 168: s = coco_string_create(L"T_array_constant expected"); break;
			case 169: s = coco_string_create(L"T_record_constant expected"); break;
			case 170: s = coco_string_create(L"T_procedural_constant expected"); break;
			case 171: s = coco_string_create(L"T_ident expected"); break;
			case 172: s = coco_string_create(L"T_unsigned_real expected"); break;
			case 173: s = coco_string_create(L"T_decimal_int expected"); break;
			case 174: s = coco_string_create(L"T_hex_int expected"); break;
			case 175: s = coco_string_create(L"T_octal_int expected"); break;
			case 176: s = coco_string_create(L"T_binary_int expected"); break;
			case 177: s = coco_string_create(L"T_quoted_string expected"); break;
			case 178: s = coco_string_create(L"T_Comment expected"); break;
			case 179: s = coco_string_create(L"T_Directive expected"); break;
			case 180: s = coco_string_create(L"T_Eof expected"); break;
			case 181: s = coco_string_create(L"T_MaxToken_ expected"); break;
			case 182: s = coco_string_create(L"??? expected"); break;
			case 183: s = coco_string_create(L"invalid FreePascal"); break;
			case 184: s = coco_string_create(L"invalid unit_"); break;
			case 185: s = coco_string_create(L"invalid identifier"); break;
			case 186: s = coco_string_create(L"invalid statement"); break;
			case 187: s = coco_string_create(L"invalid func_proc_header"); break;
			case 188: s = coco_string_create(L"invalid call_modifiers"); break;
			case 189: s = coco_string_create(L"invalid label_def"); break;
			case 190: s = coco_string_create(L"invalid constant_declaration"); break;
			case 191: s = coco_string_create(L"invalid hint_directive"); break;
			case 192: s = coco_string_create(L"invalid type_"); break;
			case 193: s = coco_string_create(L"invalid typed_constant"); break;
			case 194: s = coco_string_create(L"invalid constant"); break;
			case 195: s = coco_string_create(L"invalid helper_type"); break;
			case 196: s = coco_string_create(L"invalid structured_type"); break;
			case 197: s = coco_string_create(L"invalid simple_type"); break;
			case 198: s = coco_string_create(L"invalid string_type"); break;
			case 199: s = coco_string_create(L"invalid ordinal_type"); break;
			case 200: s = coco_string_create(L"invalid unsigned_integer"); break;
			case 201: s = coco_string_create(L"invalid packable_type_"); break;
			case 202: s = coco_string_create(L"invalid record_visibility_specifier"); break;
			case 203: s = coco_string_create(L"invalid operator_definition"); break;
			case 204: s = coco_string_create(L"invalid variable_modifier_"); break;
			case 205: s = coco_string_create(L"invalid variable_modifier_"); break;
			case 206: s = coco_string_create(L"invalid parameter_declaration"); break;
			case 207: s = coco_string_create(L"invalid default_specifier"); break;
			case 208: s = coco_string_create(L"invalid object_visibility_specifier"); break;
			case 209: s = coco_string_create(L"invalid method_definition"); break;
			case 210: s = coco_string_create(L"invalid subroutine_block"); break;
			case 211: s = coco_string_create(L"invalid class_visibility_specifier"); break;
			case 212: s = coco_string_create(L"invalid class_visibility_specifier"); break;
			case 213: s = coco_string_create(L"invalid class_part"); break;
			case 214: s = coco_string_create(L"invalid class_part"); break;
			case 215: s = coco_string_create(L"invalid method_definition2"); break;
			case 216: s = coco_string_create(L"invalid method_directives2"); break;
			case 217: s = coco_string_create(L"invalid stored_specifier"); break;
			case 218: s = coco_string_create(L"invalid generic_type_"); break;
			case 219: s = coco_string_create(L"invalid identifier_list2"); break;
			case 220: s = coco_string_create(L"invalid helper_component_list"); break;
			case 221: s = coco_string_create(L"invalid relop"); break;
			case 222: s = coco_string_create(L"invalid adop"); break;
			case 223: s = coco_string_create(L"invalid factor"); break;
			case 224: s = coco_string_create(L"invalid mulop"); break;
			case 225: s = coco_string_create(L"invalid unsigned_constant"); break;
			case 226: s = coco_string_create(L"invalid sign"); break;
			case 227: s = coco_string_create(L"invalid unsigned_number"); break;
			case 228: s = coco_string_create(L"invalid character_string"); break;
			case 229: s = coco_string_create(L"invalid simple_statement"); break;
			case 230: s = coco_string_create(L"invalid structured_statement"); break;
			case 231: s = coco_string_create(L"invalid assig_or_call"); break;
			case 232: s = coco_string_create(L"invalid assigop"); break;
			case 233: s = coco_string_create(L"invalid conditional_statement"); break;
			case 234: s = coco_string_create(L"invalid repetitive_statement"); break;
			case 235: s = coco_string_create(L"invalid try_statement"); break;
			case 236: s = coco_string_create(L"invalid for_statement"); break;
			case 237: s = coco_string_create(L"invalid for_statement"); break;
			case 238: s = coco_string_create(L"invalid else_part"); break;
			case 239: s = coco_string_create(L"invalid enumerable"); break;
			case 240: s = coco_string_create(L"invalid modifier"); break;
			case 241: s = coco_string_create(L"invalid call_modifiers2"); break;
			case 242: s = coco_string_create(L"invalid assignment_operator_definition"); break;
			case 243: s = coco_string_create(L"invalid arithmetic_operator_definition"); break;
			case 244: s = coco_string_create(L"invalid comparison_operator_definition"); break;
			case 245: s = coco_string_create(L"invalid logical_operator_definition"); break;
			case 246: s = coco_string_create(L"invalid other_operator_definition"); break;

		default:
		{
			s = QString( "generic error %1").arg(n);
		}
		break;
	}
    if( !str.isEmpty() )
        s = QString("%1 %2").arg(s).arg(str);
	error(line, col, s, path);
	//count++;
}

} // namespace

